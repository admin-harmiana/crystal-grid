<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#0f0a1e">
  <title>Crystal Grid</title>
  <style>
    /* ===== RESET & BASE ===== */
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    html, body {
      width: 100%; height: 100%;
      overflow: hidden;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
      -webkit-user-select: none;
    }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      background: #0f0a1e;
      color: #e0d6f2;
      display: flex;
      justify-content: center;
      align-items: center;
      /* Crystalline background texture */
      background-image:
        linear-gradient(60deg, rgba(168,85,247,0.03) 25%, transparent 25%),
        linear-gradient(-60deg, rgba(168,85,247,0.03) 25%, transparent 25%),
        linear-gradient(120deg, rgba(100,181,246,0.02) 25%, transparent 25%);
      background-size: 40px 70px, 40px 70px, 60px 90px;
    }

    /* ===== THEME COLORS ===== */
    :root {
      --bg-primary: #0f0a1e;
      --bg-secondary: #1a1230;
      --bg-tertiary: #241b3d;
      --accent: #a855f7;
      --accent-glow: rgba(168, 85, 247, 0.4);
      --text-primary: #e0d6f2;
      --text-secondary: #9a8cb8;
      --grid-border: #2d2252;
      --grid-cell-empty: rgba(255,255,255,0.04);

      /* Crystal colors */
      --ruby: #e91e63;
      --ruby-light: #ff6b8a;
      --ruby-glow: rgba(233, 30, 99, 0.5);
      --sapphire: #1565c0;
      --sapphire-light: #64b5f6;
      --sapphire-glow: rgba(21, 101, 192, 0.5);
      --emerald: #2e7d32;
      --emerald-light: #81c784;
      --emerald-glow: rgba(46, 125, 50, 0.5);
      --amethyst: #7b1fa2;
      --amethyst-light: #ce93d8;
      --amethyst-glow: rgba(123, 31, 162, 0.5);

      /* pressure colors removed */
    }

    /* ===== GAME CONTAINER ===== */
    #game-container {
      width: 100%;
      max-width: 420px;
      height: 100vh;
      height: 100dvh;
      position: relative;
      overflow: hidden;
      background: var(--bg-primary);
    }

    /* ===== SCREENS ===== */
    .screen {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: opacity 0.3s ease;
      z-index: 1;
    }
    .screen.hidden { display: none; }

    /* ===== MENU SCREEN ===== */
    #menu-screen {
      background: var(--bg-primary);
      gap: 24px;
    }
    .menu-title {
      font-size: 42px;
      font-weight: 800;
      letter-spacing: 2px;
      background: linear-gradient(135deg, var(--ruby-light), var(--sapphire-light), var(--emerald-light), var(--amethyst-light));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    .menu-subtitle {
      font-size: 14px;
      color: var(--text-secondary);
      margin-top: -12px;
    }
    .menu-best {
      font-size: 18px;
      color: var(--text-secondary);
    }
    .menu-best span {
      color: var(--accent);
      font-weight: 700;
    }
    .btn {
      background: linear-gradient(135deg, var(--accent), #7c3aed);
      border: none;
      color: white;
      font-size: 18px;
      font-weight: 700;
      padding: 16px 48px;
      border-radius: 12px;
      cursor: pointer;
      letter-spacing: 1px;
      transition: transform 0.1s;
    }
    .btn:active { transform: scale(0.95); }
    .btn-small {
      font-size: 14px;
      padding: 10px 24px;
      background: var(--bg-tertiary);
      border: 1px solid var(--grid-border);
    }

    /* ===== GAME SCREEN ===== */
    #game-screen {
      justify-content: flex-start;
      padding-top: env(safe-area-inset-top, 8px);
      z-index: 1;
    }

    /* Header */
    .game-header {
      width: 100%;
      padding: 4px 16px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .score-display {
      font-size: 28px;
      font-weight: 800;
      color: var(--text-primary);
      transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1), text-shadow 0.3s, color 0.3s;
    }
    .score-display.score-bump {
      transform: scale(1.3);
      text-shadow: 0 0 12px var(--accent-glow);
    }
    .score-display.score-crystal-glow {
      color: #d0b0ff;
      text-shadow: 0 0 12px var(--accent-glow), 0 0 30px rgba(168,85,247,0.5);
    }
    .best-display {
      font-size: 12px;
      color: var(--text-secondary);
    }
    .header-right {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .combo-badge {
      font-size: 22px;
      font-weight: 900;
      color: #ffd700;
      text-shadow: 0 0 10px #ffd700, 0 0 20px #ff8c00;
      opacity: 0;
      transition: opacity 0.2s, transform 0.2s;
      transform: scale(0.8);
    }
    .combo-badge.active {
      opacity: 1;
      transform: scale(1);
      animation: comboPulse 0.5s ease-in-out infinite;
    }
    .combo-badge.bump {
      animation: comboBump 0.32s ease;
    }
    @keyframes comboBump {
      0% { transform: scale(1); }
      50% { transform: scale(1.7); }
      100% { transform: scale(1); }
    }
    @keyframes comboPulse {
      0%, 100% { transform: scale(1); text-shadow: 0 0 10px #ffd700, 0 0 20px #ff8c00; }
      50% { transform: scale(1.15); text-shadow: 0 0 16px #ffd700, 0 0 32px #ff8c00; }
    }

    /* Large centered combo overlay on grid */
    .combo-overlay {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      pointer-events: none;
      z-index: 20;
    }
    .combo-overlay-label {
      font-size: 20px;
      font-weight: 700;
      color: rgba(224,214,242,0.9);
      text-transform: uppercase;
      letter-spacing: 6px;
      animation: comboLabelIn 0.7s ease-out forwards;
    }
    @keyframes comboLabelIn {
      0% { transform: translateY(10px) scale(0.5); opacity: 0; }
      30% { transform: translateY(-2px) scale(1.1); opacity: 1; }
      100% { transform: translateY(0) scale(1); opacity: 0; }
    }
    .combo-overlay-number {
      font-size: 92px;
      font-weight: 900;
      color: #fff;
      text-shadow:
        0 0 26px var(--accent-glow),
        0 0 70px var(--accent-glow),
        0 0 110px rgba(168,85,247,0.4),
        0 2px 6px rgba(0,0,0,0.85);
      -webkit-text-stroke: 1.8px rgba(168,85,247,0.7);
      animation: comboNumberPop 1.1s ease-out forwards;
      line-height: 1;
    }
    @keyframes comboNumberPop {
      0% { transform: scale(0); opacity: 0; filter: brightness(3.5); }
      15% { transform: scale(1.6); opacity: 1; filter: brightness(2.2); }
      30% { transform: scale(0.9); opacity: 1; filter: brightness(1.2); }
      45% { transform: scale(1.05); opacity: 1; filter: brightness(1); }
      70% { transform: scale(1); opacity: 0.8; }
      100% { transform: scale(0.95); opacity: 0; }
    }

    /* Grid crystalline glow on combo */
    #game-grid.crystal-pulse {
      border-color: rgba(168,85,247,0.7) !important;
      box-shadow:
        0 0 0 1px rgba(168,85,247,0.35),
        0 0 18px rgba(168,85,247,0.5),
        0 0 40px rgba(168,85,247,0.3),
        0 0 80px rgba(168,85,247,0.18),
        inset 0 0 26px rgba(168,85,247,0.14);
      transition: box-shadow 0.2s ease-out, border-color 0.2s ease-out;
    }
    #game-grid.crystal-pulse-intense {
      border-color: rgba(233,30,99,0.6) !important;
      box-shadow:
        0 0 0 2px rgba(233,30,99,0.35),
        0 0 20px rgba(233,30,99,0.6),
        0 0 55px rgba(168,85,247,0.5),
        0 0 110px rgba(168,85,247,0.3),
        inset 0 0 32px rgba(233,30,99,0.16);
    }

    /* Crystalline vignette during combos */
    .grid-wrapper.crystal-vignette::before {
      content: '';
      position: absolute;
      inset: -15px;
      border-radius: 16px;
      background: radial-gradient(ellipse at center, transparent 30%, rgba(168,85,247,0.28) 70%, rgba(100,20,180,0.5) 100%);
      pointer-events: none;
      z-index: 5;
      animation: vignetteFlash 1.2s ease-out forwards;
    }
    @keyframes vignetteFlash {
      0% { opacity: 0; }
      15% { opacity: 1; }
      100% { opacity: 0; }
    }

    /* Crystal shard edge particles */
    .crystal-shard {
      position: absolute;
      pointer-events: none;
      z-index: 25;
      background: white;
      clip-path: polygon(50% 0%, 80% 40%, 100% 100%, 0% 100%, 20% 40%);
      animation: shardDrift var(--shard-dur, 700ms) ease-out forwards;
    }
    @keyframes shardDrift {
      0% { transform: translate(0,0) rotate(0deg) scale(1); opacity: 0.9; }
      100% { transform: translate(var(--shard-dx,0px), var(--shard-dy,0px)) rotate(var(--shard-rot,90deg)) scale(0); opacity: 0; }
    }
    .settings-btn {
      background: none;
      border: none;
      color: var(--text-secondary);
      font-size: 22px;
      cursor: pointer;
      padding: 6px;
    }

    /* Pressure meter removed — grid fullness is visually obvious */

    /* Grid wrapper */
    .grid-wrapper {
      padding: 4px 8px;
      width: 100%;
      display: flex;
      justify-content: center;
      position: relative;
    }
    #game-grid {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      grid-template-rows: repeat(8, 1fr);
      gap: 2px;
      width: min(calc(100vw - 24px), 370px);
      height: min(calc(100vw - 24px), 370px);
      background: var(--bg-secondary);
      border: 2px solid var(--grid-border);
      border-radius: 8px;
      padding: 4px;
      position: relative;
      /* Gem-cut border effect */
      box-shadow:
        0 0 0 1px rgba(168,85,247,0.15),
        0 0 20px rgba(168,85,247,0.08),
        inset 0 0 15px rgba(0,0,0,0.3);
    }

    /* Particle container */
    #particle-container {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 20;
      overflow: hidden;
    }

    /* Grid cells */
    .grid-cell {
      border-radius: 3px;
      background: var(--grid-cell-empty);
      position: relative;
      transition: background 0.15s ease;
    }
    .grid-cell.preview-ruby {
      background: linear-gradient(135deg, var(--ruby-light), var(--ruby));
      opacity: 0.55;
      box-shadow: inset 0 1px 3px rgba(255,255,255,0.3);
    }
    .grid-cell.preview-sapphire {
      background: linear-gradient(135deg, var(--sapphire-light), var(--sapphire));
      opacity: 0.55;
      box-shadow: inset 0 1px 3px rgba(255,255,255,0.3);
    }
    .grid-cell.preview-emerald {
      background: linear-gradient(135deg, var(--emerald-light), var(--emerald));
      opacity: 0.55;
      box-shadow: inset 0 1px 3px rgba(255,255,255,0.3);
    }
    .grid-cell.preview-amethyst {
      background: linear-gradient(135deg, var(--amethyst-light), var(--amethyst));
      opacity: 0.55;
      box-shadow: inset 0 1px 3px rgba(255,255,255,0.3);
    }

    /* Crystal cell colors — vibrant gem style */
    .grid-cell.cell-ruby {
      background: linear-gradient(135deg, var(--ruby-light) 0%, var(--ruby) 100%);
      box-shadow:
        inset 0 2px 4px rgba(255,255,255,0.5),
        inset 0 -2px 4px rgba(0,0,0,0.4),
        0 0 12px var(--ruby-glow),
        0 2px 6px rgba(0,0,0,0.5);
      border: 1px solid rgba(255,255,255,0.15);
    }
    .grid-cell.cell-sapphire {
      background: linear-gradient(135deg, var(--sapphire-light) 0%, var(--sapphire) 100%);
      box-shadow:
        inset 0 2px 4px rgba(255,255,255,0.5),
        inset 0 -2px 4px rgba(0,0,0,0.4),
        0 0 12px var(--sapphire-glow),
        0 2px 6px rgba(0,0,0,0.5);
      border: 1px solid rgba(255,255,255,0.15);
    }
    .grid-cell.cell-emerald {
      background: linear-gradient(135deg, var(--emerald-light) 0%, var(--emerald) 100%);
      box-shadow:
        inset 0 2px 4px rgba(255,255,255,0.5),
        inset 0 -2px 4px rgba(0,0,0,0.4),
        0 0 12px var(--emerald-glow),
        0 2px 6px rgba(0,0,0,0.5);
      border: 1px solid rgba(255,255,255,0.15);
    }
    .grid-cell.cell-amethyst {
      background: linear-gradient(135deg, var(--amethyst-light) 0%, var(--amethyst) 100%);
      box-shadow:
        inset 0 2px 4px rgba(255,255,255,0.5),
        inset 0 -2px 4px rgba(0,0,0,0.4),
        0 0 12px var(--amethyst-glow),
        0 2px 6px rgba(0,0,0,0.5);
      border: 1px solid rgba(255,255,255,0.15);
    }

    /* Clearing animation — staggered via JS animationDelay */
    .grid-cell.clearing {
      animation: cellClear 0.4s ease-out forwards;
      will-change: transform, opacity;
    }
    @keyframes cellClear {
      0%   { transform: scale(1); opacity: 1; }
      15%  { transform: scale(1.12); opacity: 1; }
      35%  { transform: scale(0.85) rotate(6deg); opacity: 0.9; }
      55%  { transform: scale(0.4) rotate(-12deg) translateY(-8px); opacity: 0.5; }
      100% { transform: scale(0) rotate(-25deg) translateY(-18px); opacity: 0; }
    }

    /* Temporary white flash overlay per clearing cell */
    .cell-flash {
      position: absolute;
      border-radius: 3px;
      background: white;
      pointer-events: none;
      will-change: opacity;
      animation: cellFlashAnim 0.3s ease-out forwards;
    }
    @keyframes cellFlashAnim {
      0%   { opacity: 0.85; }
      100% { opacity: 0; }
    }

    /* Shimmer wave — overlaid on cleared rows/cols */
    .clear-shimmer {
      position: absolute;
      pointer-events: none;
      z-index: 15;
      border-radius: 4px;
    }
    .clear-shimmer.row-shimmer {
      height: var(--cell-size, 40px);
      left: 0;
      right: 0;
      background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.15) 30%, rgba(255,255,255,0.85) 48%, rgba(168,85,247,0.6) 55%, transparent 100%);
      background-size: 200% 100%;
      animation: shimmerSweepH 0.35s ease-out forwards;
    }
    .clear-shimmer.col-shimmer {
      width: var(--cell-size, 40px);
      top: 0;
      bottom: 0;
      background: linear-gradient(180deg, transparent 0%, rgba(255,255,255,0.15) 30%, rgba(255,255,255,0.85) 48%, rgba(168,85,247,0.6) 55%, transparent 100%);
      background-size: 100% 200%;
      animation: shimmerSweepV 0.35s ease-out forwards;
    }
    @keyframes shimmerSweepH {
      0% { background-position: -100% 0; opacity: 1; }
      70% { opacity: 0.8; }
      100% { background-position: 200% 0; opacity: 0; }
    }
    @keyframes shimmerSweepV {
      0% { background-position: 0 -100%; opacity: 1; }
      70% { opacity: 0.8; }
      100% { background-position: 0 200%; opacity: 0; }
    }

    /* Resonance dim overlay — single element instead of per-cell filter */
    .resonance-dim-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      pointer-events: none;
      z-index: 4;
      border-radius: 6px;
      will-change: opacity;
      animation: resDimIn 0.4s ease-out forwards;
    }
    @keyframes resDimIn {
      0%   { opacity: 0; }
      100% { opacity: 1; }
    }

    /* Resonance target highlight — static box-shadow, animate only transform+opacity */
    .grid-cell.res-target {
      z-index: 5;
      box-shadow: 0 0 18px currentColor;
      will-change: transform, opacity;
      animation: resTargetLight 0.35s ease-in-out forwards;
    }
    @keyframes resTargetLight {
      0%   { transform: scale(1); opacity: 0.3; }
      50%  { transform: scale(1.18); opacity: 1; }
      100% { transform: scale(1.12); opacity: 1; }
    }

    /* Resonance shatter — violent rotation, no filter */
    .grid-cell.res-shatter {
      z-index: 6;
      will-change: transform, opacity;
      animation: resShatter 0.5s ease-out forwards;
    }
    @keyframes resShatter {
      0%   { transform: scale(1.3); opacity: 1; }
      20%  { transform: scale(0.7) rotate(45deg); opacity: 0.8; }
      50%  { transform: scale(0.3) rotate(120deg) translateY(-10px); opacity: 0.4; }
      100% { transform: scale(0) rotate(200deg) translateY(-20px); opacity: 0; }
    }

    /* Colored flash overlay for resonance shatter */
    .res-cell-flash {
      position: absolute;
      border-radius: 3px;
      pointer-events: none;
      will-change: opacity;
      animation: resCellFlashAnim 0.4s ease-out forwards;
    }
    @keyframes resCellFlashAnim {
      0%   { opacity: 0.95; }
      30%  { opacity: 0.7; }
      100% { opacity: 0; }
    }

    /* Grid flash overlay */
    .grid-flash {
      position: absolute;
      inset: -4px;
      border-radius: 12px;
      opacity: 0;
      pointer-events: none;
      z-index: 10;
      animation: gridFlash 0.35s ease-out forwards;
    }
    @keyframes gridFlash {
      0% { opacity: 0.5; }
      40% { opacity: 0.25; }
      100% { opacity: 0; }
    }

    /* Particles */
    .particle {
      position: absolute;
      border-radius: 50%;
      pointer-events: none;
      will-change: transform, opacity;
      animation: particleFly var(--duration, 400ms) ease-out forwards;
    }
    .particle.diamond {
      border-radius: 1px;
    }
    @keyframes particleFly {
      0%   { transform: rotate(var(--rot, 0deg)) translate(0, 0) scale(1); opacity: 1; }
      60%  { transform: rotate(var(--rot, 0deg)) translate(calc(var(--dx, 0px) * 0.7), calc(var(--dy, 0px) * 0.6)) scale(0.6); opacity: 0.8; }
      100% { transform: rotate(var(--rot, 0deg)) translate(var(--dx, 0px), calc(var(--dy, 0px) + 15px)) scale(0); opacity: 0; }
    }

    /* Fast micro-sparks for resonance */
    .spark {
      position: absolute;
      border-radius: 50%;
      pointer-events: none;
      will-change: transform, opacity;
      background: white;
      animation: sparkFly var(--duration, 300ms) ease-out forwards;
    }
    @keyframes sparkFly {
      0%   { transform: translate(0, 0) scale(1); opacity: 1; }
      100% { transform: translate(var(--dx, 0px), var(--dy, 0px)) scale(0); opacity: 0; }
    }

    /* Placement settle bounce */
    .grid-cell.cell-settle {
      will-change: transform;
      animation: cellSettle 0.06s ease-out forwards;
    }
    @keyframes cellSettle {
      0% { transform: scale(1.08); }
      100% { transform: scale(1); }
    }

    /* Neighbor micro-response */
    .grid-cell.cell-neighbor-pulse {
      will-change: transform;
      animation: neighborPulse 0.08s ease-out forwards;
    }
    @keyframes neighborPulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.03); }
      100% { transform: scale(1); }
    }

    /* Anticipation glow before clear */
    .anticipation-glow {
      position: absolute;
      border-radius: 3px;
      background: white;
      pointer-events: none;
      will-change: opacity;
      animation: anticipationPulse var(--dur, 160ms) ease-in forwards;
    }
    @keyframes anticipationPulse {
      0% { opacity: 0; }
      100% { opacity: 0.2; }
    }

    /* Combo background response */
    #combo-bg {
      position: absolute;
      inset: 0;
      border-radius: 8px;
      pointer-events: none;
      z-index: 0;
      opacity: 0;
      transition: opacity 0.4s ease, background 0.4s ease;
    }

    /* ===== PIECE TRAY ===== */
    .tray-wrapper {
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 6px 8px 4px;
    }
    #piece-tray {
      display: flex;
      justify-content: space-around;
      align-items: center;
      width: 100%;
      max-width: 370px;
      gap: 8px;
    }
    .tray-piece {
      display: grid;
      gap: 2px;
      padding: 8px;
      min-width: 105px;
      min-height: 84px;
      place-content: center;
      background: rgba(255,255,255,0.03);
      border: 1px solid var(--grid-border);
      border-radius: 8px;
      cursor: grab;
      transition: transform 0.15s, opacity 0.15s;
      touch-action: none;
    }
    .tray-piece:active { cursor: grabbing; }
    .tray-piece.placed {
      opacity: 0.12;
      pointer-events: none;
      transform: scale(0.8);
    }
    .tray-piece.dragging {
      opacity: 0.4;
      transform: scale(0.9);
    }
    .tray-cell {
      width: 18px;
      height: 18px;
      border-radius: 2px;
      position: relative;
    }
    .tray-cell.empty { background: transparent; }
    .tray-cell.cell-ruby {
      background: linear-gradient(135deg, var(--ruby-light), var(--ruby));
      box-shadow: 0 0 6px var(--ruby-glow);
    }
    .tray-cell.cell-sapphire {
      background: linear-gradient(135deg, var(--sapphire-light), var(--sapphire));
      box-shadow: 0 0 6px var(--sapphire-glow);
    }
    .tray-cell.cell-emerald {
      background: linear-gradient(135deg, var(--emerald-light), var(--emerald));
      box-shadow: 0 0 6px var(--emerald-glow);
    }
    .tray-cell.cell-amethyst {
      background: linear-gradient(135deg, var(--amethyst-light), var(--amethyst));
      box-shadow: 0 0 6px var(--amethyst-glow);
    }


    /* Floating drag piece */
    #drag-ghost {
      position: fixed;
      pointer-events: none;
      z-index: 100;
      display: none;
      gap: 2px;
      opacity: 0.9;
    }
    #drag-ghost .tray-cell {
      border-radius: 2px;
    }

    /* ===== GAME OVER SCREEN ===== */
    #gameover-screen {
      background: rgba(15, 10, 30, 0.95);
      gap: 16px;
      z-index: 50;
    }
    .gameover-title {
      font-size: 36px;
      font-weight: 800;
    }
    .gameover-title.new-best {
      background: linear-gradient(135deg, #ffd700, #ff8c00);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    .gameover-score {
      font-size: 48px;
      font-weight: 800;
      color: var(--accent);
    }
    .gameover-stats {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin: 12px 0;
    }
    .stat-item { text-align: center; }
    .stat-value {
      font-size: 22px;
      font-weight: 700;
      color: var(--text-primary);
    }
    .stat-label {
      font-size: 11px;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    /* ===== TUTORIAL OVERLAY ===== */
    #tutorial-overlay {
      position: absolute;
      inset: 0;
      background: rgba(15, 10, 30, 0.92);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 60;
      gap: 16px;
      padding: 24px;
    }
    #tutorial-overlay.hidden { display: none; }
    .tutorial-title {
      font-size: 24px;
      font-weight: 800;
      color: var(--text-primary);
    }
    .tutorial-text {
      font-size: 14px;
      color: var(--text-secondary);
      text-align: center;
      line-height: 1.6;
      max-width: 300px;
    }
    .tutorial-colors {
      display: flex;
      gap: 12px;
      margin: 4px 0;
    }
    .tutorial-color-swatch {
      width: 28px;
      height: 28px;
      border-radius: 5px;
    }
    .tutorial-highlight {
      color: var(--accent);
      font-weight: 700;
    }

    /* ===== SETTINGS OVERLAY ===== */
    #settings-overlay {
      position: absolute;
      inset: 0;
      background: var(--bg-primary);
      display: flex;
      flex-direction: column;
      align-items: center;
      z-index: 55;
      padding: 60px 24px 40px;
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }
    #settings-overlay.hidden { display: none; }
    .settings-title {
      font-size: 22px;
      font-weight: 700;
      margin-bottom: 24px;
      color: var(--text-primary);
    }
    .settings-card {
      width: 100%;
      max-width: 320px;
      background: var(--bg-secondary);
      border-radius: 14px;
      padding: 4px 16px;
      margin-bottom: 16px;
    }
    .setting-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 14px 0;
    }
    .setting-row:not(:last-child) {
      border-bottom: 1px solid var(--grid-border);
    }
    .setting-label {
      font-size: 15px;
      color: var(--text-primary);
    }
    .settings-section-title {
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 1.5px;
      text-transform: uppercase;
      color: var(--text-secondary);
      max-width: 320px;
      width: 100%;
      padding: 0 4px;
      margin-bottom: 8px;
    }
    .settings-card .btn-small {
      width: 100%;
      margin: 0;
    }
    .settings-card .btn-small:not(:last-child) {
      margin-bottom: 8px;
    }
    .settings-link {
      display: block;
      width: 100%;
      padding: 13px 0;
      text-align: left;
      color: var(--text-primary);
      background: transparent;
      border: none;
      cursor: pointer;
      font-size: 15px;
    }
    .settings-link:not(:last-child) {
      border-bottom: 1px solid var(--grid-border);
    }
    #settings-close-btn {
      margin-top: 8px;
      max-width: 320px;
      width: 100%;
    }
    .legal-overlay {
      position: absolute;
      inset: 0;
      background: rgba(8, 6, 16, 0.96);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 60;
      gap: 12px;
      padding: 20px;
    }
    .legal-overlay.hidden { display: none; }
    .legal-card {
      width: 320px;
      max-height: 70vh;
      overflow: auto;
      background: rgba(20, 16, 30, 0.95);
      border: 1px solid var(--grid-border);
      border-radius: 14px;
      padding: 16px;
      box-shadow: 0 0 30px rgba(0,0,0,0.4);
    }
    .legal-title {
      font-size: 18px;
      font-weight: 800;
      margin-bottom: 8px;
    }
    .legal-text {
      font-size: 13px;
      line-height: 1.5;
      color: var(--text-secondary);
      white-space: pre-wrap;
    }
    .legal-actions {
      display: flex;
      gap: 10px;
      margin-top: 12px;
    }
    /* ===== ADS (MONETIZED BUILD) ===== */
    #ad-banner {
      width: 100%;
      height: 60px;
      margin-top: 10px;
      background: linear-gradient(90deg, rgba(40,40,60,0.8), rgba(20,20,35,0.8));
      border: 1px solid var(--grid-border);
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-secondary);
      font-size: 12px;
      letter-spacing: 1px;
      text-transform: uppercase;
    }
    #rewarded-overlay {
      position: absolute;
      inset: 0;
      background: rgba(8, 6, 16, 0.96);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 70;
      gap: 12px;
      padding: 20px;
    }
    #rewarded-overlay.hidden { display: none; }
    .rewarded-card {
      width: 320px;
      background: rgba(20, 16, 30, 0.95);
      border: 1px solid var(--grid-border);
      border-radius: 14px;
      padding: 16px;
      text-align: center;
      box-shadow: 0 0 30px rgba(0,0,0,0.4);
    }
    .rewarded-title {
      font-size: 18px;
      font-weight: 800;
      margin-bottom: 6px;
    }
    .rewarded-text {
      font-size: 13px;
      line-height: 1.5;
      color: var(--text-secondary);
    }
    .rewarded-actions {
      display: flex;
      gap: 10px;
      margin-top: 12px;
      justify-content: center;
    }
    .toggle {
      width: 48px;
      height: 28px;
      background: var(--bg-tertiary);
      border: 1px solid var(--grid-border);
      border-radius: 14px;
      cursor: pointer;
      position: relative;
      transition: background 0.2s;
    }
    .toggle.active {
      background: var(--accent);
      border-color: var(--accent);
    }
    .toggle::after {
      content: '';
      position: absolute;
      width: 22px;
      height: 22px;
      background: white;
      border-radius: 50%;
      top: 2px;
      left: 2px;
      transition: transform 0.2s;
    }
    .toggle.active::after { transform: translateX(20px); }

    /* ===== SCORE POPUP ===== */
    .score-popup {
      position: absolute;
      font-size: 26px;
      font-weight: 900;
      pointer-events: none;
      z-index: 30;
      animation: scoreFloat 1.1s ease-out forwards;
      text-shadow: 0 0 10px currentColor, 0 0 25px currentColor;
      -webkit-text-stroke: 0.5px rgba(255,255,255,0.3);
    }
    @keyframes scoreFloat {
      0% { transform: translateY(0) scale(0.5); opacity: 0; }
      12% { transform: translateY(-8px) scale(1.3); opacity: 1; }
      30% { transform: translateY(-20px) scale(1.05); opacity: 1; }
      100% { transform: translateY(-90px) scale(0.9); opacity: 0; }
    }

    /* Resonance label */
    .resonance-label {
      position: absolute;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0);
      font-size: 42px;
      font-weight: 900;
      color: white;
      text-shadow: 0 0 40px var(--accent), 0 0 80px var(--accent), 0 0 120px var(--accent);
      z-index: 40;
      pointer-events: none;
      animation: resonancePop 1.5s ease-out forwards;
      letter-spacing: 4px;
      text-transform: uppercase;
    }
    @keyframes resonancePop {
      0% { transform: translate(-50%, -50%) scale(0) rotate(-5deg); opacity: 0; }
      12% { transform: translate(-50%, -50%) scale(1.6) rotate(2deg); opacity: 1; }
      30% { transform: translate(-50%, -50%) scale(1.1) rotate(0deg); opacity: 1; }
      70% { transform: translate(-50%, -50%) scale(1.05); opacity: 0.9; }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
    }
  </style>
</head>
<body>
  <div id="game-container">
    <!-- MENU SCREEN -->
    <div id="menu-screen" class="screen">
      <div class="menu-title">CRYSTAL GRID</div>
      <div class="menu-subtitle">Match colors. Clear lines. Resonate.</div>
      <div class="menu-best">Best: <span id="menu-best-score">0</span></div>
      <button class="btn" id="play-btn">PLAY</button>
      <button class="btn btn-small" id="menu-settings-btn">Settings</button>
    </div>

    <!-- GAME SCREEN -->
    <div id="game-screen" class="screen hidden">
      <div class="game-header">
        <div>
          <div class="score-display" id="score-display">0</div>
          <div class="best-display">Best: <span id="game-best-score">0</span></div>
        </div>
        <div class="header-right">
          <div class="combo-badge" id="combo-badge">x2</div>
          <button class="settings-btn" id="game-settings-btn">&#9881;</button>
        </div>
      </div>
      <!-- pressure gauge removed — grid fullness is visually obvious -->
      <div class="grid-wrapper">
        <div id="combo-bg"></div>
        <div id="game-grid"></div>
        <div id="particle-container"></div>
      </div>
      <div class="tray-wrapper">
        <div id="piece-tray"></div>
        <div id="ad-banner">Ad Banner</div>
      </div>
    </div>

    <!-- GAME OVER SCREEN -->
    <div id="gameover-screen" class="screen hidden">
      <div class="gameover-title" id="gameover-title">GAME OVER</div>
      <div class="gameover-score" id="gameover-score">0</div>
      <div class="gameover-stats">
        <div class="stat-item">
          <div class="stat-value" id="stat-lines">0</div>
          <div class="stat-label">Lines</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="stat-resonances">0</div>
          <div class="stat-label">Resonances</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="stat-pieces">0</div>
          <div class="stat-label">Pieces</div>
        </div>
        <div class="stat-item">
          <div class="stat-value" id="stat-best-chain">0</div>
          <div class="stat-label">Best Chain</div>
        </div>
      </div>
      <button class="btn" id="play-again-btn">PLAY AGAIN</button>
      <button class="btn btn-small" id="gameover-menu-btn">Menu</button>
    </div>

    <!-- TUTORIAL OVERLAY -->
    <div id="tutorial-overlay" class="hidden">
      <div class="tutorial-title">HOW TO PLAY</div>
      <div class="tutorial-text">
        Drag <span class="tutorial-highlight">crystal pieces</span> from the tray onto the grid.
      </div>
      <div class="tutorial-text">
        Complete a full <span class="tutorial-highlight">row or column</span> to clear it.
      </div>
      <div class="tutorial-colors">
        <div class="tutorial-color-swatch" style="background: linear-gradient(135deg, var(--ruby-light), var(--ruby))"></div>
        <div class="tutorial-color-swatch" style="background: linear-gradient(135deg, var(--sapphire-light), var(--sapphire))"></div>
        <div class="tutorial-color-swatch" style="background: linear-gradient(135deg, var(--emerald-light), var(--emerald))"></div>
        <div class="tutorial-color-swatch" style="background: linear-gradient(135deg, var(--amethyst-light), var(--amethyst))"></div>
      </div>
      <div class="tutorial-text">
        When a cleared line has <span class="tutorial-highlight">5+ same-color</span> crystals in a row,
        <span class="tutorial-highlight">ALL</span> of that color on the board shatter!
      </div>
      <div class="tutorial-text" style="font-size: 12px;">
        This is <span class="tutorial-highlight">RESONANCE</span> &mdash; the key to massive combos.
      </div>
      <button class="btn" id="tutorial-btn">GOT IT!</button>
    </div>

    <!-- SETTINGS OVERLAY -->
    <div id="settings-overlay" class="hidden">
      <div class="settings-title">Settings</div>
      <div class="settings-card">
        <div class="setting-row">
          <span class="setting-label">Sound</span>
          <div class="toggle active" id="toggle-sound"></div>
        </div>
        <div class="setting-row">
          <span class="setting-label">Haptics</span>
          <div class="toggle active" id="toggle-haptics"></div>
        </div>
        <div class="setting-row">
          <span class="setting-label">Low Flash</span>
          <div class="toggle" id="toggle-lowflash"></div>
        </div>
      </div>
      <div class="settings-section-title">Game</div>
      <div class="settings-card" style="padding: 12px 16px;">
        <button class="btn btn-small" id="settings-restart-btn">Restart Game</button>
        <button class="btn btn-small" id="settings-home-btn">Go to Menu</button>
      </div>
      <div class="settings-section-title">Legal & About</div>
      <div class="settings-card">
        <button class="settings-link" data-legal-kind="privacy" data-legal-link="https://example.com/privacy">Privacy Policy</button>
        <button class="settings-link" data-legal-kind="terms" data-legal-link="https://example.com/terms">Terms of Service</button>
        <button class="settings-link" data-legal-kind="about" data-legal-link="https://example.com/about">About Us</button>
      </div>
      <button class="btn btn-small" id="settings-close-btn">Close</button>
    </div>

    <!-- LEGAL OVERLAY -->
    <div id="legal-overlay" class="legal-overlay hidden">
      <div class="legal-card">
        <div class="legal-title" id="legal-title">Privacy Policy</div>
        <div class="legal-text" id="legal-text"></div>
        <div class="legal-actions">
          <button class="btn btn-small" id="legal-open-url-btn">Open URL</button>
          <button class="btn btn-small" id="legal-close-btn">Close</button>
        </div>
      </div>
    </div>

    <!-- REWARDED OVERLAY -->
    <div id="rewarded-overlay" class="hidden">
      <div class="rewarded-card">
        <div class="rewarded-title">Second Chance</div>
        <div class="rewarded-text">Watch a short ad to continue with a refreshed board.</div>
        <div class="rewarded-actions">
          <button class="btn btn-small" id="rewarded-watch-btn">Watch Ad</button>
          <button class="btn btn-small" id="rewarded-skip-btn">No Thanks</button>
        </div>
      </div>
    </div>

    <!-- DRAG GHOST -->
    <div id="drag-ghost"></div>
  </div>

  <script>
    // ===== CONSTANTS =====
    const MONETIZED_BUILD = true;
    const AD_CONFIG = {
      bannerEnabled: true,
      rewardedEnabled: true
    };
    const GRID_SIZE = 8;
    const COLORS = ['ruby', 'sapphire', 'emerald', 'amethyst'];
    const COLOR_HEX = { ruby: '#e91e63', sapphire: '#1565c0', emerald: '#2e7d32', amethyst: '#7b1fa2' };
    const COLOR_LIGHT_HEX = { ruby: '#ff6b8a', sapphire: '#64b5f6', emerald: '#81c784', amethyst: '#ce93d8' };
    const DRAG_OFFSET_Y = -169;

    // ===== PIECE DEFINITIONS =====
    const PIECE_SHAPES = [
      { name: 'dot', shape: [[1]] },
      { name: 'h2', shape: [[1,1]] },
      { name: 'v2', shape: [[1],[1]] },
      { name: 'h3', shape: [[1,1,1]] },
      { name: 'v3', shape: [[1],[1],[1]] },
      { name: 'l3', shape: [[1,0],[1,1]] },
      { name: 'j3', shape: [[0,1],[1,1]] },
      { name: 's3', shape: [[0,1],[1,1]] },
      { name: 'l3r', shape: [[1,1],[1,0]] },
      { name: 'h4', shape: [[1,1,1,1]] },
      { name: 'v4', shape: [[1],[1],[1],[1]] },
      { name: 'o4', shape: [[1,1],[1,1]] },
      { name: 't4', shape: [[1,1,1],[0,1,0]] },
      { name: 's4', shape: [[0,1,1],[1,1,0]] },
      { name: 'z4', shape: [[1,1,0],[0,1,1]] },
      { name: 'l4', shape: [[1,0],[1,0],[1,1]] },
      { name: 'j4', shape: [[0,1],[0,1],[1,1]] },
      { name: 'h5', shape: [[1,1,1,1,1]] },
      { name: 'v5', shape: [[1],[1],[1],[1],[1]] },
      { name: 'plus', shape: [[0,1,0],[1,1,1],[0,1,0]] },
    ];

    const PIECE_WEIGHTS = {
      'dot': 8, 'h2': 10, 'v2': 10,
      'h3': 8, 'v3': 8, 'l3': 6, 'j3': 6, 's3': 6, 'l3r': 6,
      'h4': 4, 'v4': 4, 'o4': 5, 't4': 4, 's4': 4, 'z4': 4, 'l4': 4, 'j4': 4,
      'h5': 1, 'v5': 1, 'plus': 1,
    };

    // ===== DIFFICULTY SCALING =====
    const DIFFICULTY_LEVELS = [
      { score: 0, maxSize: 4, awkwardWeight: 0.40, fitBias: 0.03 },
      { score: 500, maxSize: 4, awkwardWeight: 0.45, fitBias: 0.04 },
      { score: 1500, maxSize: 5, awkwardWeight: 0.55, fitBias: 0.05 },
      { score: 3000, maxSize: 5, awkwardWeight: 0.65, fitBias: 0.06 },
      { score: 6000, maxSize: 5, awkwardWeight: 0.75, fitBias: 0.07 },
      { score: 10000, maxSize: 5, awkwardWeight: 0.80, fitBias: 0.08 },
    ];
    const AWKWARD_NAMES = new Set(['l3', 'j3', 's3', 'l3r', 't4', 's4', 'z4', 'l4', 'j4']);

    function getDifficulty() {
      for (let i = DIFFICULTY_LEVELS.length - 1; i >= 0; i--) {
        if (score >= DIFFICULTY_LEVELS[i].score) return DIFFICULTY_LEVELS[i];
      }
      return DIFFICULTY_LEVELS[0];
    }

    // ===== GAME STATE =====
    let grid = [];
    let gridCells = [];  // gridCells[y][x] = DOM element
    let score = 0;
    let highScore = 0;
    let trayPieces = [];
    let nextTrayPieces = [];
    let stats = { lines: 0, resonances: 0, pieces: 0, bestChain: 0 };
    let comboCounter = 0;
    let comboGrace = 0; // placements without clearing before combo resets (max 3)
    let soundEnabled = true;
    let hapticsEnabled = true;
    let lowFlash = false;
    let tutorialShown = false;
    let gameActive = false;
    let isAnimating = false;

    // Drag state
    let dragPieceIndex = -1;
    let isDragging = false;
    let lastPreviewX = -1;
    let lastPreviewY = -1;
    let stickyAnchor = null;      // {x, y} — last valid grid anchor
    let stickyFingerPos = null;   // {cx, cy} — finger pos when anchor was set
    const STICKY_RADIUS = 120;    // px — max drift before sticky clears

    // Cached grid layout
    let cachedGridRect = null;
    let cachedCellPlusGap = 0;
    let cachedCellSize = 0;
    let metricsRAF = 0;
    const GRID_PADDING = 4;

    // Audio
    let audioCtx = null;
    let audioResumeArmed = false;
    let audioResumeHandler = null;
    let audioUnlockHandler = null;

    // ===== INITIALIZATION =====
    function init() {
      loadSettings();
      updateSettingsUI();
      showScreen('menu');
      initHapticSwitch();
      armInitialAudioUnlock();
      if (MONETIZED_BUILD) initAds();

      document.getElementById('play-btn').addEventListener('click', startGame);
      document.getElementById('play-again-btn').addEventListener('click', startGame);
      document.getElementById('gameover-menu-btn').addEventListener('click', () => showScreen('menu'));
      document.getElementById('tutorial-btn').addEventListener('click', dismissTutorial);
      document.getElementById('menu-settings-btn').addEventListener('click', openSettings);
      document.getElementById('game-settings-btn').addEventListener('click', openSettings);
      document.getElementById('settings-close-btn').addEventListener('click', closeSettings);
      document.getElementById('settings-restart-btn').addEventListener('click', restartGameFromSettings);
      document.getElementById('settings-home-btn').addEventListener('click', goHomeFromSettings);
      document.querySelectorAll('[data-legal-link]').forEach(el => {
        el.addEventListener('click', () => openLegal(el.dataset.legalKind, el.dataset.legalLink));
      });
      document.getElementById('toggle-sound').addEventListener('click', () => toggleSetting('sound'));
      document.getElementById('toggle-haptics').addEventListener('click', () => toggleSetting('haptics'));
      document.getElementById('toggle-lowflash').addEventListener('click', () => toggleSetting('lowflash'));
      document.getElementById('legal-close-btn').addEventListener('click', closeLegal);
      document.getElementById('legal-open-url-btn').addEventListener('click', () => {
        if (currentLegalUrl) openExternal(currentLegalUrl);
      });
      document.getElementById('rewarded-watch-btn').addEventListener('click', () => {
        hideRewardedPrompt();
        showRewardedAd(() => reviveFromAd());
      });
      document.getElementById('rewarded-skip-btn').addEventListener('click', () => {
        hideRewardedPrompt();
        showGameOverScreen();
      });

      document.addEventListener('touchmove', handleDrag, { passive: false });
      document.addEventListener('mousemove', handleDrag);
      document.addEventListener('touchend', endDrag);
      document.addEventListener('mouseup', endDrag);
      window.addEventListener('resize', updateGridMetrics);
      document.addEventListener('visibilitychange', handleVisibilityChange);
      window.addEventListener('pageshow', handleVisibilityChange);

      document.getElementById('menu-best-score').textContent = highScore.toLocaleString();
    }

    // ===== PERSISTENCE =====
    function loadSettings() {
      highScore = parseInt(localStorage.getItem('crystalgrid_highscore') || '0');
      soundEnabled = localStorage.getItem('crystalgrid_sound') !== 'off';
      hapticsEnabled = localStorage.getItem('crystalgrid_haptics') !== 'false';
      lowFlash = localStorage.getItem('crystalgrid_lowflash') === 'true';
      tutorialShown = localStorage.getItem('crystalgrid_tutorial') === 'done';
    }

    function saveSettings() {
      localStorage.setItem('crystalgrid_sound', soundEnabled ? 'on' : 'off');
      localStorage.setItem('crystalgrid_haptics', String(hapticsEnabled));
      localStorage.setItem('crystalgrid_lowflash', String(lowFlash));
    }

    function saveHighScore() {
      if (score > highScore) {
        highScore = score;
        localStorage.setItem('crystalgrid_highscore', String(highScore));
      }
    }

    // ===== SCREEN MANAGEMENT =====
    function showScreen(name) {
      document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
      const screen = document.getElementById(name + '-screen');
      if (screen) screen.classList.remove('hidden');
      if (name === 'menu') {
        document.getElementById('menu-best-score').textContent = highScore.toLocaleString();
      }
      if (name === 'game') {
        requestAnimationFrame(() => updateGridMetrics());
      }
    }

    // ===== ADS (MONETIZED BUILD) =====
    let rewardedUsed = false;
    function initAds() {
      const banner = document.getElementById('ad-banner');
      if (!AD_CONFIG.bannerEnabled && banner) banner.style.display = 'none';
    }
    function showRewardedPrompt() {
      if (!AD_CONFIG.rewardedEnabled || rewardedUsed) return false;
      document.getElementById('rewarded-overlay').classList.remove('hidden');
      return true;
    }
    function hideRewardedPrompt() {
      document.getElementById('rewarded-overlay').classList.add('hidden');
    }
    function showRewardedAd(onComplete) {
      // TODO: Replace with real rewarded ad SDK integration
      setTimeout(() => {
        if (onComplete) onComplete();
      }, 300);
    }
    function reviveFromAd() {
      rewardedUsed = true;
      gameActive = true;
      isAnimating = false;
      isDragging = false;
      clearPlacementPreview();
      // Remove some blocks to create space, then refresh tray
      const filled = [];
      for (let y = 0; y < GRID_SIZE; y++)
        for (let x = 0; x < GRID_SIZE; x++)
          if (grid[y][x] !== 0) filled.push({ x, y });
      for (let i = 0; i < Math.min(10, filled.length); i++) {
        const idx = Math.floor(Math.random() * filled.length);
        const c = filled.splice(idx, 1)[0];
        grid[c.y][c.x] = 0;
      }
      renderGrid();
      advanceTray();
      renderTray();
      showScreen('game');
    }
    function showGameOverScreen() {
      const isNewBest = score >= highScore && score > 0;
      const titleEl = document.getElementById('gameover-title');
      titleEl.textContent = isNewBest ? 'NEW BEST!' : 'GAME OVER';
      titleEl.className = 'gameover-title' + (isNewBest ? ' new-best' : '');
      if (isNewBest) playSound('highscore');
      document.getElementById('gameover-score').textContent = score.toLocaleString();
      document.getElementById('stat-lines').textContent = stats.lines;
      document.getElementById('stat-resonances').textContent = stats.resonances;
      document.getElementById('stat-pieces').textContent = stats.pieces;
      document.getElementById('stat-best-chain').textContent = stats.bestChain;
      showScreen('gameover');
    }

    function openSettings() { document.getElementById('settings-overlay').classList.remove('hidden'); }
    function closeSettings() { document.getElementById('settings-overlay').classList.add('hidden'); }
    function restartGameFromSettings() {
      closeSettings();
      startGame();
    }
    function goHomeFromSettings() {
      closeSettings();
      gameActive = false;
      isAnimating = false;
      isDragging = false;
      dragPieceIndex = -1;
      stickyAnchor = null;
      stickyFingerPos = null;
      clearPlacementPreview();
      document.getElementById('drag-ghost').style.display = 'none';
      document.querySelectorAll('.tray-piece.dragging').forEach(el => el.classList.remove('dragging'));
      showScreen('menu');
    }

    let currentLegalUrl = '';
    const LEGAL_CONTENT = {
      privacy: {
        title: 'Privacy Policy',
        text:
`Crystal Grid does not collect, store, or share personal data.

We do not use analytics, advertising, or tracking.

Game data such as your best score and settings are stored locally on your device only.`
      },
      terms: {
        title: 'Terms of Service',
        text:
`Crystal Grid is provided \"as is\" without warranties of any kind.

By using the app you agree that use is at your own risk.

For questions, contact support.`
      },
      about: {
        title: 'About Us',
        text:
`Crystal Grid is a puzzle game built with a focus on feel, flow, and satisfying feedback.

Thanks for playing.`
      }
    };

    function openLegal(kind, url) {
      const entry = LEGAL_CONTENT[kind] || LEGAL_CONTENT.privacy;
      currentLegalUrl = url || '';
      document.getElementById('legal-title').textContent = entry.title;
      document.getElementById('legal-text').textContent = entry.text;
      document.getElementById('legal-overlay').classList.remove('hidden');
    }

    function closeLegal() {
      document.getElementById('legal-overlay').classList.add('hidden');
    }

    function openExternal(url) {
      if (!url) return;
      if (window.Capacitor && window.Capacitor.Plugins && window.Capacitor.Plugins.Browser) {
        window.Capacitor.Plugins.Browser.open({ url });
        return;
      }
      window.open(url, '_blank');
    }

    function toggleSetting(key) {
      if (key === 'sound') soundEnabled = !soundEnabled;
      else if (key === 'haptics') hapticsEnabled = !hapticsEnabled;
      else if (key === 'lowflash') lowFlash = !lowFlash;
      updateSettingsUI();
      saveSettings();
      if (key === 'sound' && soundEnabled) ensureAudioContextActive(true);
    }

    function updateSettingsUI() {
      document.getElementById('toggle-sound').classList.toggle('active', soundEnabled);
      document.getElementById('toggle-haptics').classList.toggle('active', hapticsEnabled);
      document.getElementById('toggle-lowflash').classList.toggle('active', lowFlash);
    }

    function ensureAudioContextActive(fromGesture) {
      if (!soundEnabled) return;
      try {
        if (!audioCtx || audioCtx.state === 'closed') {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          reverbSend = null;
        }
        if (audioCtx && audioCtx.state === 'suspended') {
          const resumePromise = audioCtx.resume();
          if (resumePromise && typeof resumePromise.catch === 'function') {
            resumePromise.catch(() => {});
          }
        }
      } catch (e) {}
      if (fromGesture) audioResumeArmed = false;
    }

    function armInitialAudioUnlock() {
      if (audioUnlockHandler) return;
      audioUnlockHandler = () => {
        ensureAudioContextActive(true);
        if (audioCtx && audioCtx.state === 'running') {
          document.removeEventListener('pointerdown', audioUnlockHandler, true);
          document.removeEventListener('touchstart', audioUnlockHandler, true);
          document.removeEventListener('mousedown', audioUnlockHandler, true);
          audioUnlockHandler = null;
        }
      };
      document.addEventListener('pointerdown', audioUnlockHandler, true);
      document.addEventListener('touchstart', audioUnlockHandler, true);
      document.addEventListener('mousedown', audioUnlockHandler, true);
    }

    function armAudioResume() {
      if (audioResumeArmed) return;
      audioResumeArmed = true;
      if (!audioResumeHandler) {
        audioResumeHandler = () => {
          audioResumeArmed = false;
          ensureAudioContextActive(true);
          document.removeEventListener('touchstart', audioResumeHandler, { passive: true });
          document.removeEventListener('mousedown', audioResumeHandler);
        };
      }
      document.addEventListener('touchstart', audioResumeHandler, { passive: true });
      document.addEventListener('mousedown', audioResumeHandler);
    }

    function handleVisibilityChange() {
      if (!soundEnabled || !audioCtx) return;
      if (document.visibilityState === 'visible' || document.visibilityState === 'hidden') {
        if (audioCtx.state !== 'running') armAudioResume();
      }
    }

    // ===== GRID PREFILL =====
    function prefillGrid() {
      // Scatter 24-38 random cells across the grid (+20%), not just the bottom
      const count = 24 + Math.floor(Math.random() * 15);
      const candidates = [];
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          candidates.push({ x, y });
        }
      }
      // Shuffle and pick
      for (let i = candidates.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [candidates[i], candidates[j]] = [candidates[j], candidates[i]];
      }
      for (let i = 0; i < count; i++) {
        const { x, y } = candidates[i];
        grid[y][x] = COLORS[Math.floor(Math.random() * COLORS.length)];
      }
    }

    // ===== GAME START =====
    function startGame() {
      ensureAudioContextActive(true);

      grid = Array.from({ length: GRID_SIZE }, () => Array(GRID_SIZE).fill(0));
      prefillGrid();
      score = 0;
      scoreDisplayValue = 0;
      comboCounter = 0;
      comboGrace = 0;
      stats = { lines: 0, resonances: 0, pieces: 0, bestChain: 0 };
      gameActive = true;
      isAnimating = false;

      createGrid();
      renderGrid();
      updateScoreDisplay();
      // pressure meter removed
      updateComboDisplay();

      // Generate current + next pieces
      nextTrayPieces = generatePieceSet();
      advanceTray();
      renderTray();

      showScreen('game');
      if (!tutorialShown) document.getElementById('tutorial-overlay').classList.remove('hidden');
    }

    function dismissTutorial() {
      document.getElementById('tutorial-overlay').classList.add('hidden');
      tutorialShown = true;
      localStorage.setItem('crystalgrid_tutorial', 'done');
    }

    // ===== GRID RENDERING =====
    function updateGridMetrics() {
      const gridEl = document.getElementById('game-grid');
      cachedGridRect = gridEl.getBoundingClientRect();
      cachedCellPlusGap = (cachedGridRect.width - GRID_PADDING * 2) / GRID_SIZE;
      cachedCellSize = cachedCellPlusGap - 2;  // 2px gap
    }

    function createGrid() {
      const gridEl = document.getElementById('game-grid');
      gridEl.innerHTML = '';
      gridCells = [];
      for (let y = 0; y < GRID_SIZE; y++) {
        gridCells[y] = [];
        for (let x = 0; x < GRID_SIZE; x++) {
          const cell = document.createElement('div');
          cell.className = 'grid-cell';
          cell.dataset.x = x;
          cell.dataset.y = y;
          gridCells[y][x] = cell;
          gridEl.appendChild(cell);
        }
      }
      updateGridMetrics();
    }

    // WARNING: This resets ALL cell classes. Never call mid-animation
    // (clearing/resonance) or you'll strip animation classes early.
    function renderGrid() {
      if (!gridCells.length) createGrid();
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          const cell = gridCells[y][x];
          cell.className = 'grid-cell';
          cell.style.animationDelay = '';
          if (grid[y][x]) cell.classList.add('cell-' + grid[y][x]);
        }
      }
      if (isDragging && stickyAnchor && dragPieceIndex >= 0) {
        lastPreviewX = -1;
        lastPreviewY = -1;
        showColoredPreview(stickyAnchor.x, stickyAnchor.y, trayPieces[dragPieceIndex].color);
      }
    }

    function updateCell(x, y) {
      if (!gridCells.length) return;
      const cell = gridCells[y][x];
      cell.classList.remove('cell-ruby', 'cell-sapphire', 'cell-emerald', 'cell-amethyst',
        'clearing', 'res-target', 'res-shatter');
      cell.style.animationDelay = '';
      if (grid[y][x]) cell.classList.add('cell-' + grid[y][x]);
    }

    // ===== PIECE GENERATION =====
    function weightedPick(pieces, weights) {
      let total = 0;
      for (let i = 0; i < weights.length; i++) total += weights[i];
      let r = Math.random() * total;
      for (let i = 0; i < pieces.length; i++) {
        r -= weights[i];
        if (r <= 0) return pieces[i];
      }
      return pieces[pieces.length - 1];
    }

    function fitScoredWeights(pieces, fitBias) {
      return pieces.map(p => {
        const base = PIECE_WEIGHTS[p.name] || 1;
        const fit = countPlacements(p);
        return base * (1 + fit * fitBias);
      });
    }

    function pickRandomShape() {
      const diff = getDifficulty();

      // Filter pieces by max size for current difficulty
      const maxCells = diff.maxSize;
      const eligible = PIECE_SHAPES.filter(p => {
        const cellCount = p.shape.flat().filter(c => c === 1).length;
        return cellCount <= maxCells;
      });

      // Decide if we force an awkward piece
      if (Math.random() < diff.awkwardWeight) {
        const awkward = eligible.filter(p => AWKWARD_NAMES.has(p.name));
        if (awkward.length > 0) {
          return weightedPick(awkward, fitScoredWeights(awkward, diff.fitBias));
        }
      }

      // Normal weighted pick from eligible pieces, biased by fit
      return weightedPick(eligible, fitScoredWeights(eligible, diff.fitBias));
    }

    function pickColor(existing) {
      if (existing.length === 2 && existing[0] === existing[1]) {
        const others = COLORS.filter(c => c !== existing[0]);
        return others[Math.floor(Math.random() * others.length)];
      }
      return COLORS[Math.floor(Math.random() * COLORS.length)];
    }

    function generatePieceSet() {
      const pieces = [];
      const colors = [];
      for (let i = 0; i < 3; i++) {
        const pieceData = pickRandomShape();
        const color = pickColor(colors);
        colors.push(color);
        pieces.push({ shape: pieceData.shape, color, placed: false });
      }
      return pieces;
    }

    function advanceTray() {
      trayPieces = nextTrayPieces;
      // Soft re-roll: if no piece in the tray fits anywhere, regenerate once
      if (!trayPieces.some(p => canPlacePieceAnywhere(p))) {
        trayPieces = generatePieceSet();
      }
      nextTrayPieces = generatePieceSet();
    }

    // ===== TRAY RENDERING =====
    function renderTray() {
      const trayEl = document.getElementById('piece-tray');
      trayEl.innerHTML = '';
      trayPieces.forEach((piece, idx) => {
        const pieceEl = document.createElement('div');
        if (piece.placed) {
          pieceEl.className = 'tray-piece placed';
          pieceEl.style.visibility = 'hidden';
          trayEl.appendChild(pieceEl);
          return;
        }
        pieceEl.className = 'tray-piece';
        pieceEl.style.gridTemplateColumns = `repeat(${piece.shape[0].length}, 18px)`;
        pieceEl.dataset.index = idx;

        for (let y = 0; y < piece.shape.length; y++) {
          for (let x = 0; x < piece.shape[0].length; x++) {
            const cell = document.createElement('div');
            cell.className = 'tray-cell';
            cell.classList.add(piece.shape[y][x] ? 'cell-' + piece.color : 'empty');
            pieceEl.appendChild(cell);
          }
        }

        if (!piece.placed) {
          pieceEl.addEventListener('touchstart', (e) => startDrag(e, idx), { passive: false });
          pieceEl.addEventListener('mousedown', (e) => startDrag(e, idx));
        }
        trayEl.appendChild(pieceEl);
      });
    }

    // ===== DRAG & DROP =====
    function startDrag(e, pieceIndex) {
      if (!gameActive || isAnimating || trayPieces[pieceIndex].placed) return;
      e.preventDefault();
      ensureAudioContextActive(true);
      playSound('grab');
      haptic([12], { gesture: true });
      dragPieceIndex = pieceIndex;
      isDragging = true;
      stickyAnchor = null;
      stickyFingerPos = null;
      const trayPieceEl = document.querySelector(`.tray-piece[data-index="${pieceIndex}"]`);
      if (trayPieceEl) trayPieceEl.classList.add('dragging');

      updateGridMetrics();

      const ghost = document.getElementById('drag-ghost');
      const piece = trayPieces[pieceIndex];
      // Match ghost cell size to grid cell size
      const gridEl = document.getElementById('game-grid');
      const gridRect = gridEl.getBoundingClientRect();
      const cellSize = Math.floor((gridRect.width - 8 - (GRID_SIZE - 1) * 2) / GRID_SIZE); // account for padding + gaps
      ghost.style.display = 'grid';
      ghost.style.gridTemplateColumns = `repeat(${piece.shape[0].length}, ${cellSize}px)`;
      ghost.innerHTML = '';
      for (let y = 0; y < piece.shape.length; y++) {
        for (let x = 0; x < piece.shape[0].length; x++) {
          const cell = document.createElement('div');
          cell.className = 'tray-cell';
          cell.style.width = cellSize + 'px';
          cell.style.height = cellSize + 'px';
          if (piece.shape[y][x]) {
            cell.classList.add('cell-' + piece.color);
          } else {
            cell.classList.add('empty');
          }
          ghost.appendChild(cell);
        }
      }
      const touch = e.touches ? e.touches[0] : e;
      positionGhost(touch.clientX, touch.clientY);
      // Use handleDrag for initial preview (reuses sticky logic)
      handleDrag(e);
    }

    function handleDrag(e) {
      if (!isDragging) return;
      e.preventDefault();
      if (!metricsRAF) {
        metricsRAF = requestAnimationFrame(() => {
          metricsRAF = 0;
          updateGridMetrics();
        });
      }
      const touch = e.touches ? e.touches[0] : e;
      const cx = touch.clientX;
      const cy = touch.clientY;

      if (isGhostOutsideGrid(cx, cy, cachedCellPlusGap / 2)) {
        if (stickyAnchor) {
          stickyAnchor = null;
          stickyFingerPos = null;
          clearPlacementPreview();
        }
        positionGhost(cx, cy);
        return;
      }

      // Always try to find a new anchor at current position
      const newAnchor = getAnchorFromPoint(cx, cy);
      const piece = trayPieces[dragPieceIndex];

      if (newAnchor && canPlacePiece(piece, newAnchor.x, newAnchor.y)) {
        // Valid new position — update sticky anchor
        if (!stickyAnchor || newAnchor.x !== stickyAnchor.x || newAnchor.y !== stickyAnchor.y) {
          stickyAnchor = newAnchor;
          stickyFingerPos = { cx, cy };
          showColoredPreview(stickyAnchor.x, stickyAnchor.y, piece.color);
        }
      } else if (!newAnchor) {
        // Off the grid — clear sticky immediately
        if (stickyAnchor) {
          stickyAnchor = null;
          stickyFingerPos = null;
          clearPlacementPreview();
        }
      } else {
        // On the grid but can't place — use sticky radius
        if (stickyAnchor && stickyFingerPos) {
          const dx = cx - stickyFingerPos.cx;
          const dy = cy - stickyFingerPos.cy;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist > STICKY_RADIUS) {
            // Finger drifted too far — clear sticky
            stickyAnchor = null;
            stickyFingerPos = null;
            clearPlacementPreview();
          }
          // Otherwise keep showing sticky preview (don't clear)
        }
      }

      // Always position the floating ghost (even if hidden, for smooth transition back)
      positionGhost(cx, cy);
    }

    function positionGhost(cx, cy) {
      const ghost = document.getElementById('drag-ghost');
      const gw = ghost.offsetWidth;
      const gh = ghost.offsetHeight;
      // Position ghost centered on the offset point
      ghost.style.left = (cx - gw / 2) + 'px';
      ghost.style.top = (cy + DRAG_OFFSET_Y - gh / 2) + 'px';
    }

    function getAnchorFromPoint(cx, cy) {
      // Anchor based on the ghost's visual top-left (matches DRAG_OFFSET_Y)
      if (!cachedGridRect) updateGridMetrics();
      if (!cachedGridRect) return null;
      const rect = cachedGridRect;
      const ghost = document.getElementById('drag-ghost');
      const gw = ghost.offsetWidth;
      const gh = ghost.offsetHeight;

      const ghostLeft = cx - gw / 2;
      const ghostTop = cy + DRAG_OFFSET_Y - gh / 2;

      const localX = ghostLeft - rect.left - GRID_PADDING;
      const localY = ghostTop - rect.top - GRID_PADDING;
      const innerW = rect.width - GRID_PADDING * 2;
      const innerH = rect.height - GRID_PADDING * 2;

      const outsideMargin = Math.max(10, cachedCellPlusGap);
      if (localX < -outsideMargin || localX > innerW + outsideMargin || localY < -outsideMargin || localY > innerH + outsideMargin) return null;

      if (dragPieceIndex < 0) {
        const gx = Math.round(localX / cachedCellPlusGap);
        const gy = Math.round(localY / cachedCellPlusGap);
        if (gx < 0 || gx > GRID_SIZE - 1 || gy < 0 || gy > GRID_SIZE - 1) return null;
        return { x: gx, y: gy };
      }

      const piece = trayPieces[dragPieceIndex];
      const pw = piece.shape[0].length;
      const ph = piece.shape.length;
      const ax = Math.round(localX / cachedCellPlusGap);
      const ay = Math.round(localY / cachedCellPlusGap);

      // Reject if anchor is out of grid bounds (don't clamp)
      if (ax < 0 || ax > GRID_SIZE - pw || ay < 0 || ay > GRID_SIZE - ph) return null;
      return { x: ax, y: ay };
    }

    function isGhostOutsideGrid(cx, cy, margin = 0) {
      if (!cachedGridRect) updateGridMetrics();
      if (!cachedGridRect) return true;
      const rect = cachedGridRect;
      const ghost = document.getElementById('drag-ghost');
      const gw = ghost.offsetWidth;
      const gh = ghost.offsetHeight;
      const ghostLeft = cx - gw / 2;
      const ghostTop = cy + DRAG_OFFSET_Y - gh / 2;
      const ghostRight = ghostLeft + gw;
      const ghostBottom = ghostTop + gh;
      const gridLeft = rect.left + GRID_PADDING;
      const gridTop = rect.top + GRID_PADDING;
      const gridRight = rect.right - GRID_PADDING;
      const gridBottom = rect.bottom - GRID_PADDING;
      return (
        ghostRight < gridLeft - margin ||
        ghostLeft > gridRight + margin ||
        ghostBottom < gridTop - margin ||
        ghostTop > gridBottom + margin
      );
    }

    function endDrag(e) {
      if (!isDragging) return;
      isDragging = false;

      // Fire haptic IMMEDIATELY at top of touchend — before any logic —
      // to stay inside the user-gesture call stack for iOS.
      // Check placement validity first (fast, synchronous).
      let anchor = stickyAnchor;
      if (!anchor && e) {
        const touch = e.changedTouches ? e.changedTouches[0] : e;
        anchor = getAnchorFromPoint(touch.clientX, touch.clientY);
      }
      const willPlace = anchor && gameActive && !isAnimating && dragPieceIndex >= 0
        && canPlacePiece(trayPieces[dragPieceIndex], anchor.x, anchor.y);
      if (willPlace) {
        haptic([35], { gesture: true });
      }

      document.getElementById('drag-ghost').style.display = 'none';
      document.getElementById('drag-ghost').style.opacity = '0.9';
      const trayPieceEl = document.querySelector(`.tray-piece[data-index="${dragPieceIndex}"]`);
      if (trayPieceEl) trayPieceEl.classList.remove('dragging');

      if (!gameActive || isAnimating || dragPieceIndex < 0) {
        clearPlacementPreview();
        stickyAnchor = null;
        stickyFingerPos = null;
        dragPieceIndex = -1;
        return;
      }

      if (anchor) {
        tryPlacePiece(dragPieceIndex, anchor.x, anchor.y);
      }

      clearPlacementPreview();
      stickyAnchor = null;
      stickyFingerPos = null;
      dragPieceIndex = -1;
    }

    // ===== PLACEMENT PREVIEW =====
    function showColoredPreview(sx, sy, color) {
      if (dragPieceIndex < 0) return;
      if (lastPreviewX === sx && lastPreviewY === sy) return;
      clearPlacementPreview();
      lastPreviewX = sx;
      lastPreviewY = sy;
      const piece = trayPieces[dragPieceIndex];
      for (let y = 0; y < piece.shape.length; y++) {
        for (let x = 0; x < piece.shape[0].length; x++) {
          if (piece.shape[y][x]) {
            const gx = sx + x, gy = sy + y;
            if (gx >= 0 && gx < GRID_SIZE && gy >= 0 && gy < GRID_SIZE) {
              gridCells[gy][gx].classList.add('preview-' + color);
            }
          }
        }
      }
    }

    function clearPlacementPreview() {
      lastPreviewX = -1;
      lastPreviewY = -1;
      if (!gridCells.length) return;
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          gridCells[y][x].classList.remove('preview-ruby', 'preview-sapphire', 'preview-emerald', 'preview-amethyst');
        }
      }
    }

    // ===== PLACEMENT LOGIC =====
    function canPlacePiece(piece, sx, sy) {
      for (let y = 0; y < piece.shape.length; y++)
        for (let x = 0; x < piece.shape[0].length; x++)
          if (piece.shape[y][x]) {
            const gx = sx + x, gy = sy + y;
            if (gx < 0 || gx >= GRID_SIZE || gy < 0 || gy >= GRID_SIZE) return false;
            if (grid[gy][gx] !== 0) return false;
          }
      return true;
    }

    function canPlacePieceAnywhere(piece) {
      for (let y = 0; y < GRID_SIZE; y++)
        for (let x = 0; x < GRID_SIZE; x++)
          if (canPlacePiece(piece, x, y)) return true;
      return false;
    }

    function countPlacements(piece) {
      let count = 0;
      for (let y = 0; y < GRID_SIZE; y++)
        for (let x = 0; x < GRID_SIZE; x++)
          if (canPlacePiece(piece, x, y)) count++;
      return count;
    }

    function tryPlacePiece(idx, sx, sy) {
      const piece = trayPieces[idx];
      if (!canPlacePiece(piece, sx, sy)) {
        return;
      }

      for (let y = 0; y < piece.shape.length; y++)
        for (let x = 0; x < piece.shape[0].length; x++)
          if (piece.shape[y][x]) {
            grid[sy + y][sx + x] = piece.color;
            updateCell(sx + x, sy + y);
          }

      // Placement satisfaction effects
      const placedCells = [];
      for (let y = 0; y < piece.shape.length; y++)
        for (let x = 0; x < piece.shape[0].length; x++)
          if (piece.shape[y][x]) placedCells.push({ x: sx + x, y: sy + y });

      // Settle bounce on placed cells
      placedCells.forEach(pc => {
        const el = gridCells[pc.y][pc.x];
        el.classList.add('cell-settle');
        setTimeout(() => el.classList.remove('cell-settle'), 80);
      });

      // Neighbor pulse on adjacent occupied cells
      const placedSet = new Set(placedCells.map(pc => `${pc.x},${pc.y}`));
      const neighbors = new Set();
      placedCells.forEach(pc => {
        [{x:pc.x-1,y:pc.y},{x:pc.x+1,y:pc.y},{x:pc.x,y:pc.y-1},{x:pc.x,y:pc.y+1}].forEach(n => {
          if (n.x >= 0 && n.x < GRID_SIZE && n.y >= 0 && n.y < GRID_SIZE && !placedSet.has(`${n.x},${n.y}`) && grid[n.y][n.x] !== 0) {
            neighbors.add(`${n.x},${n.y}`);
          }
        });
      });
      neighbors.forEach(key => {
        const [nx, ny] = key.split(',').map(Number);
        const el = gridCells[ny][nx];
        el.classList.add('cell-neighbor-pulse');
        setTimeout(() => el.classList.remove('cell-neighbor-pulse'), 100);
      });

      // Lock flash after 60ms
      setTimeout(() => {
        const gridEl = document.getElementById('game-grid');
        placedCells.forEach(pc => {
          const flash = document.createElement('div');
          flash.className = 'cell-flash';
          flash.style.left = (GRID_PADDING + pc.x * cachedCellPlusGap) + 'px';
          flash.style.top = (GRID_PADDING + pc.y * cachedCellPlusGap) + 'px';
          flash.style.width = cachedCellSize + 'px';
          flash.style.height = cachedCellSize + 'px';
          flash.style.opacity = '0.3';
          gridEl.appendChild(flash);
          setTimeout(() => flash.remove(), 120);
        });
      }, 60);

      piece.placed = true;
      stats.pieces++;
      renderTray();
      playSound('place');
      // pressure meter removed

      // Check line clears
      const cleared = checkAndClearLines();
      if (!cleared) {
        // No lines cleared — grace window (3 placements before combo resets)
        comboGrace++;
        if (comboGrace >= 3) {
          comboCounter = 0;
          comboGrace = 0;
          updateComboDisplay();
          updateComboBg();
        }
      } else {
        comboGrace = 0; // reset grace on any clear
      }

      // After animations settle, check tray state
      const checkDelay = cleared ? 800 : 300;
      setTimeout(() => {
        if (!gameActive) return;
        if (trayPieces.every(p => p.placed)) {
          advanceTray();
          renderTray();
          checkGameOver();
        } else {
          checkGameOver();
        }
      }, checkDelay);
    }

    // ===== LINE CLEARING (with full juice) =====
    function checkAndClearLines() {
      const completedRows = [];
      const completedCols = [];

      for (let y = 0; y < GRID_SIZE; y++)
        if (grid[y].every(c => c !== 0)) completedRows.push(y);
      for (let x = 0; x < GRID_SIZE; x++) {
        let full = true;
        for (let y = 0; y < GRID_SIZE; y++) if (grid[y][x] === 0) { full = false; break; }
        if (full) completedCols.push(x);
      }

      if (completedRows.length === 0 && completedCols.length === 0) return false;

      isAnimating = true;

      const cellsToClear = new Set();
      const resonanceColors = new Set();

      for (const row of completedRows) {
        for (let x = 0; x < GRID_SIZE; x++) cellsToClear.add(`${x},${row}`);
        const rc = findResonanceInLine(grid[row]);
        if (rc) resonanceColors.add(rc);
      }
      for (const col of completedCols) {
        const colData = [];
        for (let y = 0; y < GRID_SIZE; y++) {
          cellsToClear.add(`${col},${y}`);
          colData.push(grid[y][col]);
        }
        const rc = findResonanceInLine(colData);
        if (rc) resonanceColors.add(rc);
      }

      const totalLines = completedRows.length + completedCols.length;
      stats.lines += totalLines;

      // Combo
      comboCounter++;
      const comboMult = 1 + (comboCounter - 1) * 0.5;
      let lineScore;
      if (totalLines === 1) lineScore = 100;
      else if (totalLines === 2) lineScore = 300;
      else lineScore = 500;
      lineScore = Math.round(lineScore * comboMult);
      score += lineScore;

      updateComboDisplay();
      updateScoreDisplay();

      // Score popup
      const firstCell = [...cellsToClear][Math.floor(cellsToClear.size / 2)];
      const [px, py] = firstCell.split(',').map(Number);
      showScorePopup(px, py, lineScore, totalLines > 1 ? (totalLines >= 3 ? 'TRIPLE!' : 'DOUBLE!') : null);

      // Sound — pitch rises with combo
      playLineClearSound(totalLines, comboCounter);

      // Staggered clear animation
      animateStaggeredClear(cellsToClear, completedRows, completedCols, () => {
        for (const key of cellsToClear) {
          const [x, y] = key.split(',').map(Number);
          grid[y][x] = 0;
        }

        if (resonanceColors.size > 0) {
          stats.resonances++;
          setTimeout(() => processResonance(resonanceColors, 1), 250);
        } else {
          renderGrid();
          updateScoreDisplay();
          // pressure meter removed
          checkPerfectClear();
          isAnimating = false;
        }
      });

      // Screen shake — intensity scales with lines + combo
      screenShake(4 + totalLines * 3 + comboCounter * 2, 180 + totalLines * 100);

      return true;
    }

    function findResonanceInLine(lineData) {
      let runColor = null, runLength = 0;
      for (let i = 0; i < lineData.length; i++) {
        const c = lineData[i];
        if (c && c === runColor) {
          runLength++;
          if (runLength >= 5) return runColor;
        } else {
          runColor = c;
          runLength = 1;
        }
      }
      return null;
    }

    // ===== RESONANCE (3-phase dramatic sequence) =====
    function processResonance(resonanceColors, chainLevel) {
      const cellsToClear = new Set();
      for (let y = 0; y < GRID_SIZE; y++)
        for (let x = 0; x < GRID_SIZE; x++)
          if (resonanceColors.has(grid[y][x]))
            cellsToClear.add(`${x},${y}`);

      if (cellsToClear.size === 0) {
        renderGrid();
        updateScoreDisplay();
        // pressure meter removed
        checkPerfectClear();
        isAnimating = false;
        return;
      }

      const resScore = Math.round(cellsToClear.size * 50 * Math.pow(1.5, chainLevel - 1));
      score += resScore;
      if (chainLevel > stats.bestChain) stats.bestChain = chainLevel;

      // PHASE 1: DETECT — single overlay dims entire grid
      const gridEl = document.getElementById('game-grid');
      const gridRect = gridEl.getBoundingClientRect();

      const targetCells = [];
      for (const key of cellsToClear) {
        const [x, y] = key.split(',').map(Number);
        targetCells.push({ el: gridCells[y][x], x, y });
      }

      // Single dim overlay instead of per-cell filter
      const dimOverlay = document.createElement('div');
      dimOverlay.className = 'resonance-dim-overlay';
      gridEl.appendChild(dimOverlay);

      // Lift targets above the overlay
      targetCells.forEach(t => { t.el.style.zIndex = '5'; });

      // Play low rumble — building tension
      playResonanceDetectSound();
      haptic([240, 120, 240, 120, 240, 120, 240, 120]);

      setTimeout(() => {
        // PHASE 2: PROPAGATE — light up targets sequentially
        gridEl.style.transition = 'transform 0.3s ease-out';
        gridEl.style.transform = 'scale(1.03)';

        targetCells.forEach((t, i) => {
          setTimeout(() => t.el.classList.add('res-target'), i * 20);
        });

        showResonanceLabel(chainLevel, [...resonanceColors][0]);
        playResonanceChordSound([...resonanceColors][0], chainLevel);

        setTimeout(() => {
          // PHASE 3: DETONATE — explosive shatter
          // Double flash for extra punch
          if (!lowFlash) {
            const flash = document.createElement('div');
            flash.className = 'grid-flash';
            flash.style.background = COLOR_HEX[[...resonanceColors][0]] || 'white';
            document.querySelector('.grid-wrapper').appendChild(flash);
            setTimeout(() => flash.remove(), 400);
            // Second flash pulse
            setTimeout(() => {
              const flash2 = document.createElement('div');
              flash2.className = 'grid-flash';
              flash2.style.background = COLOR_LIGHT_HEX[[...resonanceColors][0]] || 'white';
              flash2.style.opacity = '0.3';
              document.querySelector('.grid-wrapper').appendChild(flash2);
              setTimeout(() => flash2.remove(), 250);
            }, 120);
          }

          screenShake(20 + chainLevel * 8, 700);
          haptic([880, 320, 720, 320, 880, 320, 1040]);

          const resColor = [...resonanceColors][0];

          // Spawn colored flash + particles + sparks for each target, staggered
          targetCells.forEach((t, i) => {
            setTimeout(() => {
              t.el.classList.remove('res-target');
              t.el.classList.add('res-shatter');

              // Colored flash overlay per cell
              const cFlash = document.createElement('div');
              cFlash.className = 'res-cell-flash';
              cFlash.style.left = (GRID_PADDING + t.x * cachedCellPlusGap) + 'px';
              cFlash.style.top = (GRID_PADDING + t.y * cachedCellPlusGap) + 'px';
              cFlash.style.width = cachedCellSize + 'px';
              cFlash.style.height = cachedCellSize + 'px';
              cFlash.style.background = COLOR_LIGHT_HEX[resColor] || 'white';
              gridEl.appendChild(cFlash);
              setTimeout(() => cFlash.remove(), 450);

              const rect = t.el.getBoundingClientRect();
              const gRect = gridEl.getBoundingClientRect();
              const pcx = rect.left - gRect.left + rect.width / 2;
              const pcy = rect.top - gRect.top + rect.height / 2;
              spawnParticles(pcx, pcy, resColor, 10, 800);
              spawnSparks(pcx, pcy, 6, 300);
            }, i * 18);
          });

          // Score popup
          showScorePopup(4, 4, resScore, chainLevel > 1 ? `CHAIN x${chainLevel}!` : 'RESONANCE!');
          playResonanceDetonateSound(chainLevel, targetCells.length);

          setTimeout(() => {
            // Cleanup: remove overlay, z-index, animation classes
            dimOverlay.remove();
            targetCells.forEach(t => {
              t.el.style.zIndex = '';
              t.el.classList.remove('res-target', 'res-shatter');
            });
            gridEl.style.transform = '';

            for (const key of cellsToClear) {
              const [x, y] = key.split(',').map(Number);
              grid[y][x] = 0;
            }

            // Check for chain clears
            const newRows = [], newCols = [];
            const newResColors = new Set();
            for (let y = 0; y < GRID_SIZE; y++)
              if (grid[y].every(c => c !== 0)) newRows.push(y);
            for (let x = 0; x < GRID_SIZE; x++) {
              let full = true;
              for (let y = 0; y < GRID_SIZE; y++) if (grid[y][x] === 0) { full = false; break; }
              if (full) newCols.push(x);
            }

            if (newRows.length > 0 || newCols.length > 0) {
              const chainCells = new Set();
              for (const row of newRows) {
                for (let x = 0; x < GRID_SIZE; x++) chainCells.add(`${x},${row}`);
                const rc = findResonanceInLine(grid[row]);
                if (rc) newResColors.add(rc);
              }
              for (const col of newCols) {
                const colData = [];
                for (let y = 0; y < GRID_SIZE; y++) {
                  chainCells.add(`${col},${y}`);
                  colData.push(grid[y][col]);
                }
                const rc = findResonanceInLine(colData);
                if (rc) newResColors.add(rc);
              }

              stats.lines += newRows.length + newCols.length;
              const chainScore = Math.round((newRows.length + newCols.length >= 3 ? 500 : newRows.length + newCols.length === 2 ? 300 : 100) * Math.pow(1.5, chainLevel));
              score += chainScore;

              animateStaggeredClear(chainCells, newRows, newCols, () => {
                for (const key of chainCells) {
                  const [x, y] = key.split(',').map(Number);
                  grid[y][x] = 0;
                }
                if (newResColors.size > 0) {
                  stats.resonances++;
                  setTimeout(() => processResonance(newResColors, chainLevel + 1), 250);
                } else {
                  renderGrid();
                  updateScoreDisplay();
                  // pressure meter removed
                  checkPerfectClear();
                  isAnimating = false;
                }
              });
            } else {
              renderGrid();
              updateScoreDisplay();
              // pressure meter removed
              checkPerfectClear();
              isAnimating = false;
            }
          }, 700);
        }, 600);
      }, 500);
    }

    // ===== ANIMATIONS =====
    function animateStaggeredClear(cellKeys, rows, cols, callback) {
      const cells = [];
      for (const key of cellKeys) {
        const [x, y] = key.split(',').map(Number);
        cells.push({ el: gridCells[y][x], x, y });
      }

      const gridEl = document.getElementById('game-grid');
      const gridRect = gridEl.getBoundingClientRect();

      const anticipation = Math.max(80, 160 - comboCounter * 10);
      cells.forEach(c => {
        const glow = document.createElement('div');
        glow.className = 'anticipation-glow';
        glow.style.left = (GRID_PADDING + c.x * cachedCellPlusGap) + 'px';
        glow.style.top = (GRID_PADDING + c.y * cachedCellPlusGap) + 'px';
        glow.style.width = cachedCellSize + 'px';
        glow.style.height = cachedCellSize + 'px';
        glow.style.setProperty('--dur', anticipation + 'ms');
        gridEl.appendChild(glow);
        setTimeout(() => glow.remove(), anticipation + 50);
      });

      setTimeout(() => {
        const lineGroups = [];
        const assignedCells = new Set();

        rows.forEach(row => {
          const group = [];
          for (let x = 0; x < GRID_SIZE; x++) {
            const key = `${x},${row}`;
            const cell = cells.find(c => c.x === x && c.y === row);
            if (cell && !assignedCells.has(key)) {
              group.push(cell);
              assignedCells.add(key);
            }
          }
          if (group.length > 0) lineGroups.push(group);
        });

        cols.forEach(col => {
          const group = [];
          for (let y = 0; y < GRID_SIZE; y++) {
            const key = `${col},${y}`;
            const cell = cells.find(c => c.x === col && c.y === y);
            if (cell && !assignedCells.has(key)) {
              group.push(cell);
              assignedCells.add(key);
            }
          }
          if (group.length > 0) lineGroups.push(group);
        });

        rows.forEach((row, ri) => {
          const shimmer = document.createElement('div');
          shimmer.className = 'clear-shimmer row-shimmer';
          shimmer.style.setProperty('--cell-size', cachedCellSize + 'px');
          shimmer.style.top = (GRID_PADDING + row * cachedCellPlusGap) + 'px';
          shimmer.style.animationDelay = (ri * 80) + 'ms';
          gridEl.appendChild(shimmer);
          setTimeout(() => shimmer.remove(), 500 + ri * 80);
        });
        cols.forEach((col, ci) => {
          const shimmer = document.createElement('div');
          shimmer.className = 'clear-shimmer col-shimmer';
          shimmer.style.setProperty('--cell-size', cachedCellSize + 'px');
          shimmer.style.left = (GRID_PADDING + col * cachedCellPlusGap) + 'px';
          shimmer.style.animationDelay = (ci * 80 + rows.length * 80) + 'ms';
          gridEl.appendChild(shimmer);
          setTimeout(() => shimmer.remove(), 500 + ci * 80 + rows.length * 80);
        });

        const staggerMs = Math.min(25, 200 / Math.max(1, cells.length));
        let maxDelay = 0;

        lineGroups.forEach((group, gi) => {
          group.forEach((c, ci) => {
            const delay = gi * 80 + ci * staggerMs;
            if (delay > maxDelay) maxDelay = delay;

            c.el.style.animationDelay = delay + 'ms';
            c.el.classList.add('clearing');

            setTimeout(() => {
              const flash = document.createElement('div');
              flash.className = 'cell-flash';
              flash.style.left = (GRID_PADDING + c.x * cachedCellPlusGap) + 'px';
              flash.style.top = (GRID_PADDING + c.y * cachedCellPlusGap) + 'px';
              flash.style.width = cachedCellSize + 'px';
              flash.style.height = cachedCellSize + 'px';
              gridEl.appendChild(flash);
              setTimeout(() => flash.remove(), 350);
            }, delay);

            const cellColor = grid[c.y][c.x];
            const rect = c.el.getBoundingClientRect();
            const pcx = rect.left - gridRect.left + rect.width / 2;
            const pcy = rect.top - gridRect.top + rect.height / 2;
            setTimeout(() => {
              if (cellColor) {
                spawnParticles(pcx, pcy, cellColor, 6, 450);
              }
            }, delay);
          });
        });

        gridEl.style.transition = 'transform 0.1s ease-out';
        gridEl.style.transform = 'scale(1.015)';
        setTimeout(() => {
          gridEl.style.transform = '';
          setTimeout(() => { gridEl.style.transition = ''; }, 150);
        }, 100);

        const totalTime = maxDelay + 400;
        setTimeout(() => {
          cells.forEach(c => {
            c.el.classList.remove('clearing');
            c.el.style.animationDelay = '';
          });
          if (callback) callback();
        }, totalTime);
      }, anticipation);
    }

    // ===== PARTICLE SYSTEM =====
    function spawnParticles(cx, cy, color, count, duration) {
      const container = document.getElementById('particle-container');
      const hex = COLOR_LIGHT_HEX[color] || '#fff';

      for (let i = 0; i < count; i++) {
        const p = document.createElement('div');
        const isDiamond = Math.random() > 0.5;
        p.className = isDiamond ? 'particle diamond' : 'particle';
        const size = 2 + Math.random() * 6;
        const angle = Math.random() * Math.PI * 2;
        const dist = 20 + Math.random() * 50;
        const dx = Math.cos(angle) * dist;
        const dy = Math.sin(angle) * dist - 15; // bias upward

        p.style.width = size + 'px';
        p.style.height = size + 'px';
        p.style.background = hex;
        p.style.boxShadow = size > 5 ? `0 0 ${size}px ${hex}, 0 0 ${size * 0.5}px white` : `0 0 ${size}px ${hex}`;
        p.style.left = cx + 'px';
        p.style.top = cy + 'px';
        p.style.setProperty('--dx', dx + 'px');
        p.style.setProperty('--dy', dy + 'px');
        p.style.setProperty('--rot', isDiamond ? '45deg' : '0deg');
        p.style.setProperty('--duration', duration + 'ms');
        p.style.animationDelay = (Math.random() * 50) + 'ms';

        container.appendChild(p);
        setTimeout(() => p.remove(), duration + 100);
      }
    }

    function spawnSparks(cx, cy, count, duration) {
      const container = document.getElementById('particle-container');
      for (let i = 0; i < count; i++) {
        const s = document.createElement('div');
        s.className = 'spark';
        const size = 1.5 + Math.random() * 2;
        const angle = Math.random() * Math.PI * 2;
        const dist = 30 + Math.random() * 60;
        const dx = Math.cos(angle) * dist;
        const dy = Math.sin(angle) * dist - 10;

        s.style.width = size + 'px';
        s.style.height = size + 'px';
        s.style.boxShadow = `0 0 ${size + 1}px white`;
        s.style.left = cx + 'px';
        s.style.top = cy + 'px';
        s.style.setProperty('--dx', dx + 'px');
        s.style.setProperty('--dy', dy + 'px');
        s.style.setProperty('--duration', duration + 'ms');
        s.style.animationDelay = (Math.random() * 40) + 'ms';

        container.appendChild(s);
        setTimeout(() => s.remove(), duration + 100);
      }
    }

    // ===== JS-DRIVEN SCREEN SHAKE =====
    function screenShake(intensity, duration) {
      if (lowFlash) return;
      const grid = document.getElementById('game-grid');
      const start = performance.now();
      function frame(now) {
        const elapsed = now - start;
        if (elapsed > duration) {
          grid.style.transform = '';
          return;
        }
        const decay = 1 - elapsed / duration;
        const dx = (Math.random() - 0.5) * 2 * intensity * decay;
        const dy = (Math.random() - 0.5) * 2 * intensity * decay;
        grid.style.transform = `translate(${dx}px, ${dy}px)`;
        requestAnimationFrame(frame);
      }
      requestAnimationFrame(frame);
    }

    function showResonanceLabel(chainLevel, color) {
      const container = document.getElementById('game-container');
      const label = document.createElement('div');
      label.className = 'resonance-label';
      label.textContent = chainLevel > 1 ? `CHAIN x${chainLevel}!` : 'RESONANCE!';
      if (color) label.style.textShadow = `0 0 30px ${COLOR_HEX[color]}, 0 0 60px ${COLOR_HEX[color]}`;
      container.appendChild(label);
      setTimeout(() => label.remove(), 1200);
    }

    function showScorePopup(gx, gy, points, label) {
      const gridEl = document.getElementById('game-grid');
      const rect = gridEl.getBoundingClientRect();
      const cellSize = rect.width / GRID_SIZE;
      const popup = document.createElement('div');
      popup.className = 'score-popup';
      popup.innerHTML = label ? `+${points}<br><span style="font-size:14px">${label}</span>` : `+${points}`;
      popup.style.color = '#d0b0ff';
      popup.style.left = (rect.left + gx * cellSize + cellSize / 2 - 30) + 'px';
      popup.style.top = (rect.top + gy * cellSize) + 'px';
      document.getElementById('game-container').appendChild(popup);
      setTimeout(() => popup.remove(), 900);
    }

    // Pressure meter removed — grid fullness is visually obvious
    function updatePressureMeter() { /* no-op */ }

    // ===== COMBO TIER SYSTEM =====
    const COMBO_TIERS = [
      { min: 0, color: 'transparent', opacity: 0, label: '' },
      { min: 2, color: '#FFB74D', opacity: 0.07, label: 'COMBO' },
      { min: 5, color: '#FF5722', opacity: 0.12, label: 'ON FIRE' },
      { min: 8, color: '#D32F2F', opacity: 0.18, label: 'BLAZING' },
      { min: 10, color: '#FFF176', opacity: 0.26, label: 'TRANSCENDENT' },
    ];

    function getComboTier(combo) {
      for (let i = COMBO_TIERS.length - 1; i >= 0; i--)
        if (combo >= COMBO_TIERS[i].min) return i;
      return 0;
    }

    function updateComboBg() {
      const bg = document.getElementById('combo-bg');
      if (!bg) return;
      const tier = getComboTier(comboCounter);
      const t = COMBO_TIERS[tier];
      if (tier === 0) {
        bg.style.opacity = '0';
      } else {
        bg.style.background = `radial-gradient(circle at center, ${t.color} 0%, transparent 75%)`;
        bg.style.opacity = String(t.opacity);
      }
    }

    let lastComboTier = 0;

    // ===== COMBO DISPLAY =====
    function updateComboDisplay() {
      const badge = document.getElementById('combo-badge');
      if (comboCounter >= 2) {
        badge.textContent = `x${comboCounter}`;
        badge.classList.add('active');
        badge.classList.remove('bump');
        void badge.offsetWidth; // reflow
        badge.classList.add('bump');
        // Show large centered combo overlay on every combo increment
        const currentTier = getComboTier(comboCounter);
        showComboOverlay(comboCounter);
        // Aggressive combo haptics (native builds use heavy impacts)
        const comboImpacts = Math.min(8, 3 + Math.floor(comboCounter / 2));
        strongHapticBurst(comboImpacts, 35, 50);
        lastComboTier = currentTier;
      } else {
        badge.classList.remove('active');
        lastComboTier = 0;
      }
      updateComboBg();
    }

    function showComboOverlay(combo) {
      const gridEl = document.getElementById('game-grid');
      const wrapper = document.querySelector('.grid-wrapper');
      // Remove any existing overlay
      const old = gridEl.querySelector('.combo-overlay');
      if (old) old.remove();

      // Build overlay with tier-specific label + number
      const tier = getComboTier(combo);
      const tierData = COMBO_TIERS[tier];
      const comboCap = 12;
      const comboNorm = Math.min(combo, comboCap);
      const comboT = comboNorm / comboCap;
      const numScale = 1 + comboNorm * 0.04;
      const overlay = document.createElement('div');
      overlay.className = 'combo-overlay';
      const label = document.createElement('div');
      label.className = 'combo-overlay-label';
      label.textContent = tierData.label || 'COMBO';
      const num = document.createElement('div');
      num.className = 'combo-overlay-number';
      num.textContent = combo >= 4 ? `${combo}!!` : combo >= 3 ? `${combo}!` : `${combo}`;
      num.style.transform = `scale(${numScale})`;
      num.style.filter = `brightness(${1 + comboT * 0.5})`;
      num.style.textShadow =
        `0 0 ${26 + comboT * 24}px var(--accent-glow), ` +
        `0 0 ${70 + comboT * 50}px var(--accent-glow), ` +
        `0 0 ${110 + comboT * 80}px rgba(168,85,247,${0.4 + comboT * 0.2}), ` +
        `0 2px 6px rgba(0,0,0,0.85)`;
      overlay.appendChild(label);
      overlay.appendChild(num);
      gridEl.appendChild(overlay);
      setTimeout(() => overlay.remove(), 1300);

      // Crystalline grid border glow
      gridEl.classList.remove('crystal-pulse', 'crystal-pulse-intense');
      void gridEl.offsetWidth;
      gridEl.classList.add(combo >= 3 ? 'crystal-pulse-intense' : 'crystal-pulse');
      setTimeout(() => gridEl.classList.remove('crystal-pulse', 'crystal-pulse-intense'), 1400);

      // Vignette
      wrapper.classList.remove('crystal-vignette');
      void wrapper.offsetWidth;
      wrapper.classList.add('crystal-vignette');
      setTimeout(() => wrapper.classList.remove('crystal-vignette'), 1300);

      // Combo flash (lowFlash respects user setting)
      if (!lowFlash) {
        const flash = document.createElement('div');
        flash.className = 'grid-flash';
        flash.style.background = 'rgba(255,255,255,0.225)';
        wrapper.appendChild(flash);
        setTimeout(() => flash.remove(), 400);
      }

      // Crystal shard edge particles
      spawnEdgeShards(gridEl, Math.min(80, 12 + combo * 8), comboT);
    }

    function spawnEdgeShards(gridEl, count, intensity = 0) {
      const w = gridEl.offsetWidth;
      const h = gridEl.offsetHeight;
      const colors = ['#d0b0ff', '#a855f7', '#e0d6f2', '#ff6b8a', '#64b5f6', '#81c784'];
      for (let i = 0; i < count; i++) {
        const shard = document.createElement('div');
        shard.className = 'crystal-shard';
        // Pick random edge position
        const edge = Math.floor(Math.random() * 4); // 0=top, 1=right, 2=bottom, 3=left
        let x, y, dx, dy;
        if (edge === 0) { x = Math.random() * w; y = -2; dx = (Math.random()-0.5)*40; dy = -(15+Math.random()*30); }
        else if (edge === 1) { x = w + 2; y = Math.random() * h; dx = 15+Math.random()*30; dy = (Math.random()-0.5)*40; }
        else if (edge === 2) { x = Math.random() * w; y = h + 2; dx = (Math.random()-0.5)*40; dy = 15+Math.random()*30; }
        else { x = -2; y = Math.random() * h; dx = -(15+Math.random()*30); dy = (Math.random()-0.5)*40; }
        const size = 3 + Math.random() * 5;
        shard.style.left = x + 'px';
        shard.style.top = y + 'px';
        shard.style.width = size + 'px';
        shard.style.height = size * 1.4 + 'px';
        shard.style.background = colors[Math.floor(Math.random() * colors.length)];
        shard.style.boxShadow = `0 0 6px ${shard.style.background}`;
        shard.style.setProperty('--shard-dx', dx + 'px');
        shard.style.setProperty('--shard-dy', dy + 'px');
        shard.style.setProperty('--shard-rot', (60 + Math.random() * 240) + 'deg');
        const dur = (500 + Math.random() * 400) * (1 + intensity * 0.6);
        shard.style.setProperty('--shard-dur', dur + 'ms');
        shard.style.animationDelay = (Math.random() * 200) + 'ms';
        gridEl.appendChild(shard);
        setTimeout(() => shard.remove(), 1000);
      }
    }

    // ===== GAME OVER =====
    function checkGameOver() {
      const unplaced = trayPieces.filter(p => !p.placed);
      if (unplaced.length === 0) return;
      if (!unplaced.some(p => canPlacePieceAnywhere(p))) gameOver('no_moves');
    }

    function checkPerfectClear() {
      if (grid.every(row => row.every(c => c === 0))) {
        score += 1000;
        updateScoreDisplay();
        playSound('perfect');
        const label = document.createElement('div');
        label.className = 'resonance-label';
        label.textContent = 'PERFECT CLEAR!';
        label.style.color = '#ffd700';
        label.style.textShadow = '0 0 30px #ffd700, 0 0 60px #ffd700';
        document.getElementById('game-container').appendChild(label);
        setTimeout(() => label.remove(), 1200);
      }
    }

    function gameOver(reason = '') {
      gameActive = false;
      isDragging = false;
      dragPieceIndex = -1;
      stickyAnchor = null;
      stickyFingerPos = null;
      clearPlacementPreview();
      document.getElementById('drag-ghost').style.display = 'none';
      document.querySelectorAll('.tray-piece.dragging').forEach(el => el.classList.remove('dragging'));
      if (scoreAnimFrame) { cancelAnimationFrame(scoreAnimFrame); scoreAnimFrame = null; }
      scoreDisplayValue = score;
      saveHighScore();
      playSound('gameover');
      haptic([100, 50, 100, 50, 100]);

      setTimeout(() => {
        if (reason === 'no_moves' && showRewardedPrompt()) return;
        showGameOverScreen();
      }, 500);
    }

    // ===== SCORE DISPLAY =====
    let scoreDisplayValue = 0;
    let scoreAnimFrame = null;
    function updateScoreDisplay() {
      const el = document.getElementById('score-display');
      const target = score;
      const start = scoreDisplayValue;
      const diff = target - start;

      // Cancel previous animation
      if (scoreAnimFrame) cancelAnimationFrame(scoreAnimFrame);

      if (diff <= 0) {
        el.textContent = target.toLocaleString();
        scoreDisplayValue = target;
      } else {
        // Animated count-up over 350ms
        const duration = Math.min(350, diff * 2);
        const startTime = performance.now();
        function tick(now) {
          const elapsed = now - startTime;
          const t = Math.min(elapsed / duration, 1);
          // Ease-out curve
          const eased = 1 - Math.pow(1 - t, 3);
          const current = Math.round(start + diff * eased);
          el.textContent = current.toLocaleString();
          scoreDisplayValue = current;
          if (t < 1) {
            scoreAnimFrame = requestAnimationFrame(tick);
          } else {
            scoreDisplayValue = target;
            el.textContent = target.toLocaleString();
          }
        }
        scoreAnimFrame = requestAnimationFrame(tick);
      }

      // Scale bump
      el.classList.add('score-bump');
      setTimeout(() => el.classList.remove('score-bump'), 250);

      // Crystal glow
      el.classList.add('score-crystal-glow');
      setTimeout(() => el.classList.remove('score-crystal-glow'), 500);

      document.getElementById('game-best-score').textContent = Math.max(score, highScore).toLocaleString();
    }

    // ===== SOUND SYSTEM (crystal cavern audio) =====
    let reverbSend = null;
    let reverbCtx = null;
    function getReverbSend() {
      if (reverbSend && audioCtx && reverbCtx === audioCtx) return reverbSend;
      if (!audioCtx) return null;
      // 4-tap Feedback Delay Network for "crystal cavern" reverb
      const input = audioCtx.createGain();
      const wet = audioCtx.createGain();
      wet.gain.value = 0.50;

      const tapConfigs = [
        { time: 0.067, fb: 0.45 },
        { time: 0.113, fb: 0.40 },
        { time: 0.179, fb: 0.35 },
        { time: 0.271, fb: 0.30 }
      ];

      for (const cfg of tapConfigs) {
        const delay = audioCtx.createDelay(1.0);
        delay.delayTime.value = cfg.time;
        const hs = audioCtx.createBiquadFilter();
        hs.type = 'highshelf';
        hs.frequency.value = 3000;
        hs.gain.value = -3;
        const fbGain = audioCtx.createGain();
        fbGain.gain.value = cfg.fb;

        input.connect(delay);
        delay.connect(hs);
        hs.connect(fbGain);
        fbGain.connect(delay);
        delay.connect(wet);
      }

      wet.connect(audioCtx.destination);
      reverbSend = input;
      reverbCtx = audioCtx;
      return input;
    }

    function makeNoise(duration) {
      const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * duration, audioCtx.sampleRate);
      const d = buf.getChannelData(0);
      for (let i = 0; i < d.length; i++) d[i] = Math.random() * 2 - 1;
      const src = audioCtx.createBufferSource();
      src.buffer = buf;
      return src;
    }

    function connectWithReverb(node, wetLevel) {
      if (!audioCtx) return;
      node.connect(audioCtx.destination);
      const reverb = getReverbSend();
      if (reverb) {
        const wetGain = audioCtx.createGain();
        wetGain.gain.value = wetLevel;
        node.connect(wetGain);
        wetGain.connect(reverb);
      }
    }

    // ===== PENTATONIC SCALE CONSTANTS =====
    const PENTA = {
      C3: 130.81, D3: 146.83, E3: 164.81, G3: 196.00, A3: 220.00,
      C4: 261.63, D4: 293.66, E4: 329.63, G4: 392.00, A4: 440.00,
      C5: 523.25, D5: 587.33, E5: 659.25, G5: 783.99, A5: 880.00,
      C6: 1046.50, D6: 1174.66, E6: 1318.51
    };
    const PENTA_UP = [
      PENTA.C4, PENTA.D4, PENTA.E4, PENTA.G4,
      PENTA.A4, PENTA.C5, PENTA.D5, PENTA.E5
    ];
    const PENTA_DOWN = [
      PENTA.E6, PENTA.D6, PENTA.C6, PENTA.A5,
      PENTA.G5, PENTA.E5, PENTA.D5, PENTA.C5,
      PENTA.A4, PENTA.G4, PENTA.E4, PENTA.D4, PENTA.C4
    ];

    // ===== MELODIC SOUND HELPERS =====
    function chime(freq, time, dur, vol, reverbWet) {
      const osc = audioCtx.createOscillator();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(freq, time);
      const g = audioCtx.createGain();
      g.gain.setValueAtTime(0.001, time);
      g.gain.linearRampToValueAtTime(vol, time + 0.003);
      g.gain.exponentialRampToValueAtTime(0.001, time + dur);
      osc.connect(g);
      connectWithReverb(g, reverbWet || 0.25);
      osc.start(time); osc.stop(time + dur);
    }

    function bellChime(freq, time, dur, vol, reverbWet) {
      chime(freq, time, dur, vol, reverbWet || 0.30);
      chime(freq * 2, time, dur * 0.6, vol * 0.3, reverbWet || 0.30);
      chime(freq * 3, time, dur * 0.35, vol * 0.12, reverbWet || 0.30);
    }

    function warmChime(freq, time, dur, vol, reverbWet) {
      const osc = audioCtx.createOscillator();
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(freq, time);
      const lp = audioCtx.createBiquadFilter();
      lp.type = 'lowpass';
      lp.frequency.setValueAtTime(freq * 4, time);
      lp.frequency.exponentialRampToValueAtTime(freq * 1.5, time + dur);
      const g = audioCtx.createGain();
      g.gain.setValueAtTime(0.001, time);
      g.gain.linearRampToValueAtTime(vol, time + 0.003);
      g.gain.exponentialRampToValueAtTime(0.001, time + dur);
      osc.connect(lp); lp.connect(g);
      connectWithReverb(g, reverbWet || 0.20);
      osc.start(time); osc.stop(time + dur);
    }

    function subBass(freq, time, dur, vol) {
      const osc = audioCtx.createOscillator();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(freq, time);
      const g = audioCtx.createGain();
      g.gain.setValueAtTime(0.001, time);
      g.gain.linearRampToValueAtTime(vol, time + 0.05);
      g.gain.setValueAtTime(vol, time + dur * 0.4);
      g.gain.exponentialRampToValueAtTime(0.001, time + dur);
      osc.connect(g);
      g.connect(audioCtx.destination);
      osc.start(time); osc.stop(time + dur);
    }

    function sparkle(freq, time, vol) {
      const osc = audioCtx.createOscillator();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(freq, time);
      const g = audioCtx.createGain();
      g.gain.setValueAtTime(vol, time);
      g.gain.exponentialRampToValueAtTime(0.001, time + 0.04);
      osc.connect(g);
      connectWithReverb(g, 0.40);
      osc.start(time); osc.stop(time + 0.04);
    }

    function playSound(type) {
      if (!soundEnabled) return;
      ensureAudioContextActive(false);
      if (!audioCtx) return;
      try {
        const now = audioCtx.currentTime;

        switch (type) {
          case 'grab': {
            // G0: Quick Swoosh — Noise sweep 300->1200Hz upward. 60ms.
            const nBuf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.060, audioCtx.sampleRate);
            const nData = nBuf.getChannelData(0);
            for (let i = 0; i < nData.length; i++) nData[i] = Math.random() * 2 - 1;
            const nSrc = audioCtx.createBufferSource();
            nSrc.buffer = nBuf;
            const bp = audioCtx.createBiquadFilter();
            bp.type = 'bandpass'; bp.Q.value = 4;
            bp.frequency.setValueAtTime(300, now);
            bp.frequency.exponentialRampToValueAtTime(1200, now + 0.060);
            const g1 = audioCtx.createGain();
            g1.gain.setValueAtTime(0.10, now);
            g1.gain.setValueAtTime(0.10, now + 0.020);
            g1.gain.exponentialRampToValueAtTime(0.001, now + 0.060);
            nSrc.connect(bp); bp.connect(g1);
            connectWithReverb(g1, 0.15);
            nSrc.start(now); nSrc.stop(now + 0.060);
            break;
          }
          case 'place': {
            // P1: Marimba Drop — 3 warm triangle ticks G4->E4->C4
            warmChime(PENTA.G4, now,         0.055, 0.09, 0.15);
            warmChime(PENTA.E4, now + 0.040, 0.055, 0.10, 0.15);
            warmChime(PENTA.C4, now + 0.080, 0.065, 0.11, 0.15);
            break;
          }
          case 'wrong': {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(200, now);
            osc.frequency.exponentialRampToValueAtTime(100, now + 0.15);
            gain.gain.setValueAtTime(0.12, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start(now); osc.stop(now + 0.2);
            break;
          }
          case 'gameover': {
            // Crystal Fade (1500ms, reverb wet 0.60)
            const chordFreqs = [440, 523, 659, 880];
            const decays = [1.500, 1.200, 0.900, 0.600];
            for (let i = 0; i < chordFreqs.length; i++) {
              const osc = audioCtx.createOscillator();
              osc.type = 'sine';
              osc.frequency.setValueAtTime(chordFreqs[i], now);
              osc.frequency.linearRampToValueAtTime(chordFreqs[i] - 12, now + decays[i]);
              const g = audioCtx.createGain();
              g.gain.setValueAtTime(0.07, now);
              g.gain.exponentialRampToValueAtTime(0.001, now + decays[i]);
              osc.connect(g);
              connectWithReverb(g, 0.60);
              osc.start(now); osc.stop(now + decays[i]);
            }
            // Descending shimmer
            const shimmerFreqs = [2637, 2349, 2093, 1760];
            for (let i = 0; i < shimmerFreqs.length; i++) {
              const t = now + i * 0.100;
              const osc = audioCtx.createOscillator();
              osc.type = 'sine';
              osc.frequency.setValueAtTime(shimmerFreqs[i], t);
              const g = audioCtx.createGain();
              g.gain.setValueAtTime(0.025, t);
              g.gain.exponentialRampToValueAtTime(0.001, t + 0.400);
              osc.connect(g);
              connectWithReverb(g, 0.60);
              osc.start(t); osc.stop(t + 0.400);
            }
            break;
          }
          case 'highscore': {
            // Crystal Crown (1000ms, reverb wet 0.70)
            const arpFreqs = [880, 1109, 1319, 1760, 2637];
            const arpTimes = [0, 0.100, 0.200, 0.300, 0.450];
            const arpDecays = [0.300, 0.300, 0.300, 0.300, 0.500];
            for (let i = 0; i < arpFreqs.length; i++) {
              const t = now + arpTimes[i];
              const osc = audioCtx.createOscillator();
              osc.type = 'sine';
              osc.frequency.setValueAtTime(arpFreqs[i], t);
              const g = audioCtx.createGain();
              g.gain.setValueAtTime(0.12, t);
              g.gain.exponentialRampToValueAtTime(0.001, t + arpDecays[i]);
              osc.connect(g);
              connectWithReverb(g, 0.70);
              osc.start(t); osc.stop(t + arpDecays[i]);
              // Inharmonic partial at freq * 2.76
              const osc2 = audioCtx.createOscillator();
              osc2.type = 'sine';
              osc2.frequency.setValueAtTime(arpFreqs[i] * 2.76, t);
              const g2 = audioCtx.createGain();
              g2.gain.setValueAtTime(0.02, t);
              g2.gain.exponentialRampToValueAtTime(0.001, t + 0.150);
              osc2.connect(g2);
              connectWithReverb(g2, 0.70);
              osc2.start(t); osc2.stop(t + 0.150);
            }
            // E major chord bloom at t=450ms
            const bloomFreqs = [1319, 1661, 1976];
            const bloomT = now + 0.450;
            for (const f of bloomFreqs) {
              const osc = audioCtx.createOscillator();
              osc.type = 'sine';
              osc.frequency.setValueAtTime(f, bloomT);
              const g = audioCtx.createGain();
              g.gain.setValueAtTime(0.001, bloomT);
              g.gain.linearRampToValueAtTime(0.05, bloomT + 0.010);
              g.gain.setValueAtTime(0.05, bloomT + 0.200);
              g.gain.exponentialRampToValueAtTime(0.001, bloomT + 0.600);
              osc.connect(g);
              connectWithReverb(g, 0.70);
              osc.start(bloomT); osc.stop(bloomT + 0.600);
            }
            // Crown shimmer at t=500ms: 10 random sines 3000-7000Hz
            const shimmerT = now + 0.500;
            for (let i = 0; i < 10; i++) {
              const freq = 3000 + Math.random() * 4000;
              const decay = 0.050 + Math.random() * 0.150;
              const osc = audioCtx.createOscillator();
              osc.type = 'sine';
              osc.frequency.setValueAtTime(freq, shimmerT);
              const g = audioCtx.createGain();
              g.gain.setValueAtTime(0.015, shimmerT);
              g.gain.exponentialRampToValueAtTime(0.001, shimmerT + decay);
              osc.connect(g);
              connectWithReverb(g, 0.70);
              osc.start(shimmerT); osc.stop(shimmerT + decay);
            }
            break;
          }
          case 'perfect': {
            // Crystal Transcendence (800ms, reverb wet 0.75)
            const chordFreqs = [440, 554, 659, 880, 1109, 1319];
            for (let i = 0; i < chordFreqs.length; i++) {
              const t = now + i * 0.005;
              const gainVal = 0.08 - i * 0.005;
              const osc = audioCtx.createOscillator();
              osc.type = 'sine';
              osc.frequency.setValueAtTime(chordFreqs[i], t);
              const g = audioCtx.createGain();
              g.gain.setValueAtTime(0.001, t);
              g.gain.linearRampToValueAtTime(gainVal, t + 0.010);
              g.gain.setValueAtTime(gainVal, t + 0.300);
              g.gain.exponentialRampToValueAtTime(0.001, t + 0.800);
              osc.connect(g);
              connectWithReverb(g, 0.75);
              osc.start(t); osc.stop(t + 0.800);
              // Detuned double at +2Hz
              const osc2 = audioCtx.createOscillator();
              osc2.type = 'sine';
              osc2.frequency.setValueAtTime(chordFreqs[i] + 2, t);
              const g2 = audioCtx.createGain();
              g2.gain.setValueAtTime(0.001, t);
              g2.gain.linearRampToValueAtTime(0.03, t + 0.010);
              g2.gain.setValueAtTime(0.03, t + 0.300);
              g2.gain.exponentialRampToValueAtTime(0.001, t + 0.800);
              osc2.connect(g2);
              connectWithReverb(g2, 0.75);
              osc2.start(t); osc2.stop(t + 0.800);
            }
            // Celestial overtones at t=100ms
            const celFreqs = [2637, 3520, 4435];
            const celGains = [0.03, 0.02, 0.015];
            const celDecays = [0.600, 0.500, 0.400];
            const celT = now + 0.100;
            for (let i = 0; i < celFreqs.length; i++) {
              const osc = audioCtx.createOscillator();
              osc.type = 'sine';
              osc.frequency.setValueAtTime(celFreqs[i], celT);
              const g = audioCtx.createGain();
              g.gain.setValueAtTime(celGains[i], celT);
              g.gain.exponentialRampToValueAtTime(0.001, celT + celDecays[i]);
              osc.connect(g);
              connectWithReverb(g, 0.75);
              osc.start(celT); osc.stop(celT + celDecays[i]);
            }
            // Ascending sparkle: 8 pings every 50ms
            const sparkleFreqs = [1760, 2093, 2349, 2637, 2960, 3322, 3729, 4186];
            for (let i = 0; i < sparkleFreqs.length; i++) {
              const t = now + i * 0.050;
              const osc = audioCtx.createOscillator();
              osc.type = 'sine';
              osc.frequency.setValueAtTime(sparkleFreqs[i], t);
              const g = audioCtx.createGain();
              g.gain.setValueAtTime(0.025, t);
              g.gain.exponentialRampToValueAtTime(0.001, t + 0.100);
              osc.connect(g);
              connectWithReverb(g, 0.75);
              osc.start(t); osc.stop(t + 0.100);
            }
            break;
          }
          default:
            break;
        }
      } catch (e) {}
    }

    function playLineClearSound(lineCount, combo) {
      // Haptics always fire, even with sound off
      if (lineCount >= 3) strongHapticBurst(6, 40, 60);
      else if (lineCount >= 2) strongHapticBurst(5, 45, 60);
      else strongHapticBurst(4, 50, 60);

      if (!soundEnabled || !audioCtx) return;
      try {
        const now = audioCtx.currentTime;
        // L2: Harp Gliss — ascending pentatonic triangle wave + gentle pad
        // Combo pitch shift: each combo step raises all pitches by one semitone
        const comboShift = Math.pow(2, (combo || 0) / 12);
        const spacing = 0.060;

        // Ascending pentatonic cascade — one note per cell across 8 cells
        PENTA_UP.forEach((freq, i) => {
          warmChime(freq * comboShift, now + i * spacing, 0.15, 0.08 + i * 0.003, 0.28);
        });

        // Gentle pad (C4 + E4 sustained underneath)
        const pad1 = audioCtx.createOscillator();
        pad1.type = 'sine';
        pad1.frequency.value = PENTA.C4 * comboShift;
        const pg1 = audioCtx.createGain();
        pg1.gain.setValueAtTime(0.001, now);
        pg1.gain.linearRampToValueAtTime(0.03, now + 0.10);
        pg1.gain.setValueAtTime(0.03, now + 0.35);
        pg1.gain.exponentialRampToValueAtTime(0.001, now + 0.60);
        pad1.connect(pg1); connectWithReverb(pg1, 0.40);
        pad1.start(now); pad1.stop(now + 0.60);

        const pad2 = audioCtx.createOscillator();
        pad2.type = 'sine';
        pad2.frequency.value = PENTA.E4 * comboShift;
        const pg2 = audioCtx.createGain();
        pg2.gain.setValueAtTime(0.001, now);
        pg2.gain.linearRampToValueAtTime(0.02, now + 0.10);
        pg2.gain.setValueAtTime(0.02, now + 0.35);
        pg2.gain.exponentialRampToValueAtTime(0.001, now + 0.60);
        pad2.connect(pg2); connectWithReverb(pg2, 0.40);
        pad2.start(now); pad2.stop(now + 0.60);

        // Multi-line bonus: extra sparkle for 2+ lines
        if (lineCount >= 2) {
          for (let i = 0; i < lineCount * 2; i++) {
            sparkle(PENTA_DOWN[i % PENTA_DOWN.length] * comboShift, now + 0.40 + i * 0.03, 0.04);
          }
        }
      } catch (e) {}
    }

    function playResonanceDetectSound() {
      strongHapticBurst(5, 45, 60);
      if (!soundEnabled || !audioCtx) return;
      try {
        const now = audioCtx.currentTime;
        // R2: Harmonic Ping — C5 + G5 + C6 simultaneous (rich bell cluster)
        bellChime(PENTA.C5, now, 0.18, 0.09, 0.35);
        chime(PENTA.G5, now + 0.005, 0.15, 0.07, 0.35);
        chime(PENTA.C6, now + 0.010, 0.12, 0.05, 0.35);
      } catch (e) {}
    }

    function playResonanceChordSound(color, chain) {
      strongHapticBurst(6, 50, 70);
      if (!soundEnabled || !audioCtx) return;
      try {
        const now = audioCtx.currentTime;
        const transpose = Math.pow(1.189, chain - 1);

        // Layer 1: 4-voice A major chord sines
        const chordFreqs = [220, 277, 330, 440];
        for (let i = 0; i < chordFreqs.length; i++) {
          const freq = chordFreqs[i] * transpose;
          const osc = audioCtx.createOscillator();
          osc.type = 'sine';
          osc.frequency.setValueAtTime(freq, now);
          const g = audioCtx.createGain();
          g.gain.setValueAtTime(0.001, now);
          g.gain.linearRampToValueAtTime(0.08, now + 0.015);
          g.gain.setValueAtTime(0.08, now + 0.300);
          g.gain.exponentialRampToValueAtTime(0.001, now + 0.600);
          osc.connect(g);
          connectWithReverb(g, 0.65);
          osc.start(now); osc.stop(now + 0.600);
        }

        // Layer 2: 4 detuned doubles
        const detunes = [1.5, 2.0, 1.8, 2.2];
        for (let i = 0; i < chordFreqs.length; i++) {
          const freq = chordFreqs[i] * transpose + detunes[i];
          const osc = audioCtx.createOscillator();
          osc.type = 'sine';
          osc.frequency.setValueAtTime(freq, now);
          const g = audioCtx.createGain();
          g.gain.setValueAtTime(0.001, now);
          g.gain.linearRampToValueAtTime(0.04, now + 0.015);
          g.gain.setValueAtTime(0.04, now + 0.300);
          g.gain.exponentialRampToValueAtTime(0.001, now + 0.600);
          osc.connect(g);
          connectWithReverb(g, 0.65);
          osc.start(now); osc.stop(now + 0.600);
        }

        // Layer 3: Glass overtones
        const glassOsc1 = audioCtx.createOscillator();
        glassOsc1.type = 'sine';
        glassOsc1.frequency.setValueAtTime(1760 * transpose, now);
        const glassG1 = audioCtx.createGain();
        glassG1.gain.setValueAtTime(0.03, now);
        glassG1.gain.exponentialRampToValueAtTime(0.001, now + 0.400);
        glassOsc1.connect(glassG1);
        connectWithReverb(glassG1, 0.65);
        glassOsc1.start(now); glassOsc1.stop(now + 0.400);

        const glassOsc2 = audioCtx.createOscillator();
        glassOsc2.type = 'sine';
        glassOsc2.frequency.setValueAtTime(2200 * transpose, now);
        const glassG2 = audioCtx.createGain();
        glassG2.gain.setValueAtTime(0.02, now);
        glassG2.gain.exponentialRampToValueAtTime(0.001, now + 0.300);
        glassOsc2.connect(glassG2);
        connectWithReverb(glassG2, 0.65);
        glassOsc2.start(now); glassOsc2.stop(now + 0.300);

        // Layer 4: Onset transient: white noise -> bandpass 2500Hz Q=6
        const nBuf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.020, audioCtx.sampleRate);
        const nData = nBuf.getChannelData(0);
        for (let i = 0; i < nData.length; i++) nData[i] = (Math.random() * 2 - 1);
        const nSrc = audioCtx.createBufferSource();
        nSrc.buffer = nBuf;
        const bp = audioCtx.createBiquadFilter();
        bp.type = 'bandpass';
        bp.frequency.value = 2500;
        bp.Q.value = 6;
        const nG = audioCtx.createGain();
        nG.gain.setValueAtTime(0.08, now);
        nG.gain.exponentialRampToValueAtTime(0.001, now + 0.020);
        nSrc.connect(bp); bp.connect(nG);
        connectWithReverb(nG, 0.65);
        nSrc.start(now); nSrc.stop(now + 0.020);
      } catch (e) {}
    }

    function playResonanceDetonateSound(chain, cellCount) {
      // Haptics always fire — scale with cell count
      const cells = cellCount || 3;
      if (cells >= 8) strongHapticBurst(8, 35, 70);
      else if (cells >= 4) strongHapticBurst(7, 40, 70);
      else strongHapticBurst(6, 45, 70);

      if (!soundEnabled || !audioCtx) return;
      try {
        const now = audioCtx.currentTime;
        // D2: Harmonic Explosion — sub impact -> C major spread chord -> pentatonic rain
        const chainShift = Math.pow(2, (chain || 0) / 12);

        // Sub impact
        subBass(PENTA.C3 * chainShift, now, 0.8, 0.14);

        // Bright impact noise
        const n = makeNoise(0.03);
        const hp = audioCtx.createBiquadFilter();
        hp.type = 'highpass'; hp.frequency.value = 2000;
        const ng = audioCtx.createGain();
        ng.gain.setValueAtTime(0.06, now);
        ng.gain.exponentialRampToValueAtTime(0.001, now + 0.03);
        n.connect(hp); hp.connect(ng); connectWithReverb(ng, 0.35);
        n.start(now); n.stop(now + 0.03);

        // Wide spread chord (staggered entry)
        const spread = [
          { freq: PENTA.C4, delay: 0.02 },
          { freq: PENTA.G4, delay: 0.04 },
          { freq: PENTA.E4, delay: 0.06 },
          { freq: PENTA.C5, delay: 0.08 },
          { freq: PENTA.G5, delay: 0.10 },
        ];
        spread.forEach(({ freq, delay }) => {
          bellChime(freq * chainShift, now + delay, 0.50, 0.07, 0.45);
        });

        // Rapid descending pentatonic rain — scale with cellCount
        const rainCount = Math.min(PENTA_DOWN.length, 6 + (cells || 3));
        for (let i = 0; i < rainCount; i++) {
          chime(PENTA_DOWN[i] * chainShift, now + 0.30 + i * 0.04, 0.06, 0.05 - i * 0.003, 0.35);
        }
      } catch (e) {}
    }

    // ===== HAPTICS =====
    // iOS Safari doesn't support navigator.vibrate().
    // Workaround: iOS 18+ triggers Taptic Engine when toggling <input type="checkbox" switch>.
    // CRITICAL: element must NOT use display:none — that removes it from render tree
    // and suppresses the haptic. Use offscreen positioning instead.
    const _isCoarsePointer = typeof window !== 'undefined' && window.matchMedia('(pointer: coarse)').matches;

    let _hapticSwitch = null;
    function initHapticSwitch() {
      if (_hapticSwitch) return;
      const input = document.createElement('input');
      input.type = 'checkbox';
      input.setAttribute('switch', '');
      input.setAttribute('aria-hidden', 'true');
      input.style.position = 'fixed';
      input.style.left = '0';
      input.style.top = '0';
      input.style.width = '1px';
      input.style.height = '1px';
      input.style.opacity = '0.01';
      input.style.zIndex = '1';
      document.body.appendChild(input);
      _hapticSwitch = input;
    }

    function _hapticTap() {
      try {
        if (!_hapticSwitch) initHapticSwitch();
        if (!_hapticSwitch) return;
        _hapticSwitch.click();
      } catch (e) {}
    }

    function haptic(pattern, options = {}) {
      if (!hapticsEnabled) return;
      const isGesture = !!options.gesture;
      // Try Capacitor Haptics plugin (native builds)
      if (window.Capacitor && window.Capacitor.Plugins && window.Capacitor.Plugins.Haptics) {
        try {
          const H = window.Capacitor.Plugins.Haptics;
          const total = Array.isArray(pattern) ? pattern.reduce((a, b) => a + b, 0) : pattern;
          if (total > 1400) {
            // Massive events: five heavy bursts
            H.impact({ style: 'HEAVY' });
            setTimeout(() => H.impact({ style: 'HEAVY' }), 50);
            setTimeout(() => H.impact({ style: 'HEAVY' }), 100);
            setTimeout(() => H.impact({ style: 'HEAVY' }), 150);
            setTimeout(() => H.impact({ style: 'HEAVY' }), 200);
          } else if (total > 1000) {
            // Huge events: four heavy bursts
            H.impact({ style: 'HEAVY' });
            setTimeout(() => H.impact({ style: 'HEAVY' }), 60);
            setTimeout(() => H.impact({ style: 'HEAVY' }), 120);
            setTimeout(() => H.impact({ style: 'HEAVY' }), 180);
          } else if (total > 600) {
            // Big events: triple heavy burst
            H.impact({ style: 'HEAVY' });
            setTimeout(() => H.impact({ style: 'HEAVY' }), 70);
            setTimeout(() => H.impact({ style: 'HEAVY' }), 140);
          } else if (total > 360) {
            // Medium events: double heavy
            H.impact({ style: 'HEAVY' });
            setTimeout(() => H.impact({ style: 'HEAVY' }), 90);
          } else if (total > 180) {
            // Small-medium: single heavy
            H.impact({ style: 'HEAVY' });
          } else {
            // Light taps (grab/place): medium
            H.impact({ style: 'MEDIUM' });
          }
          return;
        } catch (e) {}
      }
      // Try standard Vibration API (Android Chrome)
      if (navigator.vibrate) {
        navigator.vibrate(pattern);
        return;
      }
      // iOS 18+ checkbox switch workaround (touch devices only)
      if (!_isCoarsePointer) return;
      if (!isGesture && navigator.userActivation && !navigator.userActivation.isActive) return;
      _hapticTap();
    }

    function strongHapticBurst(impacts, spacing, pulse = 60) {
      if (!hapticsEnabled) return;
      const boostedImpacts = Math.min(20, impacts * 2);
      const boostedSpacing = Math.max(25, Math.floor(spacing * 0.75));
      if (window.Capacitor && window.Capacitor.Plugins && window.Capacitor.Plugins.Haptics) {
        try {
          const H = window.Capacitor.Plugins.Haptics;
          for (let i = 0; i < boostedImpacts; i++) {
            setTimeout(() => H.impact({ style: 'HEAVY' }), i * boostedSpacing);
          }
          return;
        } catch (e) {}
      }
      if (navigator.vibrate) {
        const pattern = [];
        for (let i = 0; i < boostedImpacts; i++) pattern.push(pulse, boostedSpacing);
        navigator.vibrate(pattern);
        return;
      }
      const fallback = [];
      for (let i = 0; i < boostedImpacts; i++) fallback.push(pulse, boostedSpacing);
      haptic(fallback);
    }

    // ===== INIT =====
    document.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
